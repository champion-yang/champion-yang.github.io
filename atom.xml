<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Snail Book</title>
  
  <subtitle>Snail 的知识库</subtitle>
  <link href="https://champion-yang.github.io/atom.xml" rel="self"/>
  
  <link href="https://champion-yang.github.io/"/>
  <updated>2024-07-09T09:53:03.623Z</updated>
  <id>https://champion-yang.github.io/</id>
  
  <author>
    <name>Sanil</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafka 保证数据一致性</title>
    <link href="https://champion-yang.github.io/2024/07/09/02_kafka/2027-07-09kafka05-%E5%B9%82%E7%AD%89/"/>
    <id>https://champion-yang.github.io/2024/07/09/02_kafka/2027-07-09kafka05-%E5%B9%82%E7%AD%89/</id>
    <published>2024-07-09T08:57:15.000Z</published>
    <updated>2024-07-09T09:53:03.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息系统语义概述-Overview-of-messaging-system-semantics"><a href="#消息系统语义概述-Overview-of-messaging-system-semantics" class="headerlink" title="消息系统语义概述(Overview of messaging system semantics)"></a>消息系统语义概述(Overview of messaging system semantics)</h2><p>在一个分布式发布订阅消息系统中, 组成系统的计算机总会由于各自的故障而不能工作. 在Kafka中, 一个单独的broker, 可能会在生产者发送消息到一个topic的时候宕机, 或者出现网络故障, 从而导致生产者发送消息失败. 根据生产者如何处理这样的失败, 产生了不同的语义:</p><ul><li><strong>至少一次语义(At least once semantics)</strong>: 如果生产者收到了Kafka broker的确认(acknowledgement, ack), 并且生产者的acks配置项设置为all(或-1), 这就意味着消息已经被精确一次写入Kafka topic了. 然而, 如果生产者接收ack超时或者收到了错误, 它就会认为消息没有写入Kafka topic而尝试重新发送消息. 如果broker恰好在消息已经成功写入Kafka topic后, 发送ack前, 出了故障, 生产者的重试机制就会导致这条消息被写入Kafka两次, 从而导致同样的消息会被消费者消费不止一次. 每个人都喜欢一个兴高采烈的给予者, 但是这种方式会导致重复的工作和错误的结果.</li><li><strong>至多一次语义(At most once semantics)</strong>: 如果生产者在ack超时或者返回错误的时候不重试发送消息, 那么消息有可能最终并没有写入Kafka topic中, 因此也就不会被消费者消费到. 但是为了避免重复处理的可能性, 我们接受有些消息可能被遗漏处理.</li><li><strong>精确一次语义(Exactly once semantics)</strong>: 即使生产者重试发送消息, 也只会让消息被发送给消费者一次. 精确一次语义是最令人满意的保证, 但也是最难理解的. 因为它需要消息系统本身和生产消息的应用程序还有消费消息的应用程序一起合作. 比如, 在成功消费一条消息后, 你又把消费的offset重置到之前的某个offset位置, 那么你将收到从那个offset到最新的offset之间的所有消息. 这解释了为什么消息系统和客户端程序必须合作来保证精确一次语义.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将服务器的ACK级别设置为-1, 可以保证Producer到Server之间不会丢失数据, 即At Least Once语义.<br>相对的, 将服务器ACK级别设置为0, 可以保证生产者每条消息只会被发送一次, 即At Most Once语义.</p><p>At Least Once可以保证数据不丢失, 但是不能保证数据不重复;<br>相对的, At Least Once可以保证数据不重复, 但是不能保证数据不丢失.</p><p>但是, 对于一些非常重要的信息, 比如说交易数据, 下游数据消费者要求数据既不重复也不丢失, 即Exactly Once语义.<strong>在0.11版本以前的Kafka, 对此是无能为力的, 只能保证数据不丢失</strong>, 再在下游消费者对数据做全局去重. 对于多个下游应用的情况, 每个都需要单独做全局去重, 这就对性能造成了很大影响.</p><p>0.11版本的Kafka, 引入了一项重大特性:<strong>幂等性</strong>.</p><p>开启幂等性 <code>enable.idempotence=true</code> .</p><p>所谓的幂等性就是指Producer不论向Server发送多少次重复数据, Server端都只会持久化一条. 幂等性结合At Least Once语义, 就构成了Kafka的Exactly Once语义. 即:</p><p> <code>At Least Once + 幂等性 = Exactly Once</code></p><p>Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游. 开启幂等性的Producer在初始化的时候会被分配一个PID, 发往同一Partition的消息会附带Sequence Number. 而Broker端会对<br>&lt;PID, Partition, SeqNumber&gt;做缓存, 当具有相同主键的消息提交时, Broker只会持久化一条.</p><p>但是PID重启就会变化, 同时不同的Partition也具有不同主键, 所以幂等性无法保证跨分区跨会话的 Exactly Once.</p><p>所以0.11版本的Kafka引入了事务的概念</p><p><strong>事务: 跨partition的原子性写操作</strong><br>Kafka现在支持使用新事务API原子性的对跨partition进行写操作, 该API允许producer发送批量消息到多个partition. 该功能同样支持在同一个事务中提交消费者offsets, 因此真正意义上实现了end-to-end的exactly-once delivery语义.</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p><a href="https://www.cnblogs.com/luxiaoxun/p/13048474.html">https://www.cnblogs.com/luxiaoxun/p/13048474.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息系统语义概述-Overview-of-messaging-system-semantics&quot;&gt;&lt;a href=&quot;#消息系统语义概述-Overview-of-messaging-system-semantics&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="技术" scheme="https://champion-yang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kafka" scheme="https://champion-yang.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka的消费分区分配策略</title>
    <link href="https://champion-yang.github.io/2024/07/09/02_kafka/2027-07-09kafka04-kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://champion-yang.github.io/2024/07/09/02_kafka/2027-07-09kafka04-kafka%E7%9A%84%E6%B6%88%E8%B4%B9%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</id>
    <published>2024-07-09T08:33:19.000Z</published>
    <updated>2024-07-09T08:40:42.207Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这将是一篇比较无聊的文章</p></blockquote><p>一个consumer group中有多个consumer, 一个topic有多个partition, 所以必然会涉及到partition的分配问题, 即确定那个partition由哪个consumer来消费 Kafka有三种分配策略, 一是RoundRobin, 一是Range. 高版本还有一个StickyAssignor策略 将分区的所有权从一个消费者移到另一个消费者称为重新平衡(rebalance). 当以下事件发生时, Kafka 将会进行一次分区分配:</p><ul><li>同一个 Consumer Group 内新增消费者.</li><li>消费者离开当前所属的Consumer Group, 包括shuts down或crashes.</li></ul><h2 id="Range分区分配策略"><a href="#Range分区分配策略" class="headerlink" title="Range分区分配策略"></a>Range分区分配策略</h2><p>Range是对每个Topic而言的(即一个Topic一个Topic分), 首先对同一个Topic里面的分区按照序号进行排序, 并对消费者按照字母顺序进行排序. 然后用Partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区. 如果除不尽, 那么前面几个消费者线程将会多消费一个分区. 假设n&#x3D;分区数&#x2F;消费者数量, m&#x3D;分区数%消费者数量, 那么前m个消费者每个分配n+1个分区, 后面的(消费者数<br>量-m)个消费者每个分配n个分区. 假如有10个分区, 3个消费者线程, 把分区按照序号排列<br>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<br>消费者线程为<br>C1-0, C2-0, C2-1<br>那么用partition数除以消费者线程的总数来决定每个消费者线程消费几个partition, 如果除不尽, 前面几个消费者将会多消费一个分区. 在我们的例子里面, 我们有10个分区, 3个消费者线程, 10&#x2F;3 &#x3D; 3, 而且除不尽, 那么消费者线程C1-0将会多消费一个分区, 所以最后分区分配的结果看起来是这样的:<br>C1-0:0, 1, 2, 3<br>C2-0:4, 5, 6<br>C2-1:7, 8, 9<br>如果有11个分区将会是:<br>C1-0:0, 1, 2, 3<br>C2-0:4, 5, 6, 7<br>C2-1:8, 9, 10<br>假如我们有两个主题T1, T2, 分别有10个分区, 最后的分配结果将会是这样:<br>C1-0: T1(0, 1, 2, 3) T2(0, 1, 2, 3)<br>C2-0: T1(4, 5, 6) T2(4, 5, 6)<br>C2-1: T1(7, 8, 9) T2(7, 8, 9)</p><h2 id="RoundRobinAssignor分区分配策略"><a href="#RoundRobinAssignor分区分配策略" class="headerlink" title="RoundRobinAssignor分区分配策略"></a>RoundRobinAssignor分区分配策略</h2><p>RoundRobinAssignor策略的原理是将消费组内所有消费者以及消费者所订阅的所有topic的partition按照字典序排序, 然后通过轮询方式逐个将分区以此分配给每个消费者. 使用RoundRobin策略有两个前提条件必须满足:</p><ul><li>同一个消费者组里面的所有消费者的num.streams(消费者消费线程数)必须相等; </li><li>每个消费者订阅的主题必须相同.</li></ul><p>加入按照 hashCode 排序完的topic-partitions组依次为<br>T1-5, T1-3, T1-0, T1-8, T1-2, T1-1, T1-4, T1-7, T1-6, T1-9<br>我们的消费者线程排序为<br>C1-0, C1-1, C2-0, C2-1<br>最后分区分配的结果为:<br>C1-0 将消费 T1-5, T1-2, T1-6 分区<br>C1-1 将消费 T1-3, T1-1, T1-9 分区<br>C2-0 将消费 T1-0, T1-4 分区<br>C2-1 将消费 T1-8, T1-7 分区</p><h2 id="StickyAssignor分区分配策略"><a href="#StickyAssignor分区分配策略" class="headerlink" title="StickyAssignor分区分配策略"></a>StickyAssignor分区分配策略</h2><p>Kafka从0.11.x版本开始引入这种分配策略, 它主要有两个目的:<br>分区的分配要尽可能的均匀, 分配给消费者者的主题分区数最多相差一个分区的分配尽可能的与上次分配的保持相同.</p><p>当两者发生冲突时, 第一个目标优先于第二个目标. 鉴于这两个目的, StickyAssignor策略的具体实现要比RangeAssignor和RoundRobinAssignor这两种分配策略要复杂很多.</p><p>假设消费组内有3个消费者<br>C0、C1、C2<br>它们都订阅了4个主题:<br>t0、t1、t2、t3<br>并且每个主题有2个分区, 也就是说整个消费组订阅了<br>t0p0、t0p1、t1p0、t1p1、t2p0、t2p1、t3p0、t3p1这8个分区<br>最终的分配结果如下:<br>消费者C0:t0p0、t1p1、t3p0<br>消费者C1:t0p1、t2p0、t3p1<br>消费者C2:t1p0、t2p1<br>这样初看上去似乎与采用RoundRobinAssignor策略所分配的结果相同<br>此时假设消费者C1脱离了消费组, 那么消费组就会执行再平衡操作, 进而消费分区会重新分配. 如果采<br>用RoundRobinAssignor策略, 那么此时的分配结果如下:<br>消费者C0:t0p0、t1p0、t2p0、t3p0<br>消费者C2:t0p1、t1p1、t2p1、t3p1<br>如分配结果所示, RoundRobinAssignor策略会按照消费者C0和C2进行重新轮询分配. 而如果此时使用<br>的是StickyAssignor策略, 那么分配结果为:<br>消费者C0:t0p0、t1p1、t3p0、t2p0<br>消费者C2:t1p0、t2p1、t0p1、t3p1<br>可以看到分配结果中保留了上一次分配中对于消费者C0和C2的所有分配结果, 并将原来消费者C1的”负担”分配给了剩余的两个消费者C0和C2, 最终C0和C2的分配还保持了均衡.<br>如果发生分区重分配, 那么对于同一个分区而言有可能之前的消费者和新指派的消费者不是同一个, 对于之前消费者进行到一半的处理还要在新指派的消费者中再次复现一遍, 这显然很浪费系统资源.<br>StickyAssignor策略如同其名称中的”sticky”一样, 让分配策略具备一定的”粘性”, 尽可能地让前后两次分配相同, 进而减少系统资源的损耗以及其它异常情况的发生. 到目前为止所分析的都是消费者的订阅信息都是相同的情况, 我们来看一下订阅信息不同的情况下的处理.<br>举例, 同样消费组内有3个消费者:<br>C0、C1、C2<br>集群中有3个主题:<br>t0、t1、t2<br>这3个主题分别有<br>1、2、3个分区<br>也就是说集群中有<br>t0p0、t1p0、t1p1、t2p0、t2p1、t2p2这6个分区<br>消费者C0订阅了主题t0<br>消费者C1订阅了主题t0和t1<br>消费者C2订阅了主题t0、t1和t2<br>如果此时采用RoundRobinAssignor策略:<br>消费者C0:t0p0<br>消费者C1:t1p0<br>消费者C2:t1p1、t2p0、t2p1、t2p2<br>如果此时采用的是StickyAssignor策略:<br>消费者C0:t0p0<br>消费者C1:t1p0、t1p1<br>消费者C2:t2p0、t2p1、t2p2<br>此时消费者C0脱离了消费组, 那么RoundRobinAssignor策略的分配结果为:<br>消费者C1:t0p0、t1p1<br>消费者C2:t1p0、t2p0、t2p1、t2p2<br>StickyAssignor策略, 那么分配结果为:<br>消费者C1:t1p0、t1p1、t0p0<br>消费者C2:t2p0、t2p1、t2p2<br>可以看到StickyAssignor策略保留了消费者C1和C2中原有的5个分区的分配:<br>t1p0、t1p1、t2p0、t2p1、t2p2.<br>从结果上看StickyAssignor策略比另外两者分配策略而言显得更加的优异, 这个策略的代码实现也是异<br>常复杂.</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>公众号: 大数据左右手</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这将是一篇比较无聊的文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个consumer group中有多个consumer, 一个topic有多个partition, 所以必然会涉及到partition的分配问题, 即确定那个partition由</summary>
      
    
    
    
    <category term="技术" scheme="https://champion-yang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kafka" scheme="https://champion-yang.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka 常用命令</title>
    <link href="https://champion-yang.github.io/2024/07/08/02_kafka/2024-07-08-kafka03%E5%91%BD%E4%BB%A4/"/>
    <id>https://champion-yang.github.io/2024/07/08/02_kafka/2024-07-08-kafka03%E5%91%BD%E4%BB%A4/</id>
    <published>2024-07-08T06:33:09.000Z</published>
    <updated>2024-07-09T07:02:07.205Z</updated>
    
    <content type="html"><![CDATA[<p><strong>查看所有 topic</strong></p><ul><li><code>./kafka-topics.sh --zookeeper=10.5.208.13:2181 --list</code></li></ul><p><strong>创建topic——注意: 必须指定分区和副本, 否则会报错; 不同的版本需要指定的参数不同; Replication 不能超过 brokers 数量</strong></p><ul><li><code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 3 --topic testA</code></li><li><code>bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 3 --partitions 3 --topic testA</code></li></ul><p><strong>删除topic</strong></p><ul><li><code>./kafka-topics.sh --zookeeper=10.5.208.13:2181 --topic xxx --delete</code></li></ul><p><strong>查看topic属性</strong></p><ul><li><code>./kafka-topics.sh --describe --zookeeper=10.5.208.13:2181 --topic xxx</code></li></ul><p><strong>topic增加分区</strong></p><ul><li><code>./kafka-topics.sh --alter --zookeeper=10.5.208.13:2181 --topic xxx --partitions 10</code><blockquote><p>分区数增加到10个, 如果topic的分区增加, 则分区逻辑或消息顺序将受到影响, 会引起rebalance操作</p></blockquote></li></ul><p><strong>生产数据</strong></p><ul><li><code>./kafka-console-producer.sh --broker-list localhost:9092 --topic TCP_6666</code></li></ul><p><strong>消费数据</strong></p><ul><li><code>./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first --from-beginning</code></li></ul><p><strong>重置偏移量</strong></p><ul><li><code>./kafka-consumer-groups.sh --bootstrap-server=10.5.208.13:9092 --execute --reset-offsets --topic=xxx --group=testPlatform-local-pha  --to-earliest</code></li></ul><p><strong>显示所有消费者</strong></p><ul><li><code>./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list</code></li></ul><p><strong>查看Broker磁盘信息kafka-log-dirs.sh</strong></p><ul><li><p><code>/home/master/kafka/bin/kafka-log-dirs.sh --bootstrap-server localhost:9092 --describe --topic-list vuln</code></p></li><li><p><code>/home/master/kafka/bin/kafka-configs.sh --list --bootstrap-server localhost:9092</code></p></li><li><p><code>/home/master/kafka/bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic vuln</code></p></li></ul><p><strong>查询 kafka 消费者组的信息</strong></p><ul><li><p><code>kafka=/home/master/kafka/</code></p></li><li><p><code>$kafka/bin/kafka-consumer-groups.sh --bootstrap-server=localhost:9092 --describe --group &quot;groupName&quot;</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;查看所有 topic&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./kafka-topics.sh --zookeeper=10.5.208.13:2181 --list&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;创建topic</summary>
      
    
    
    
    <category term="技术" scheme="https://champion-yang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kafka" scheme="https://champion-yang.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>python虚拟环境</title>
    <link href="https://champion-yang.github.io/2024/07/08/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://champion-yang.github.io/2024/07/08/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2024-07-08T06:14:22.000Z</published>
    <updated>2024-07-08T06:25:11.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>平常使用 anaconda 对开发环境做管理, 公司某天发了一条通知, 说 anaconda 未经授权不许使用, 存在 xxx 风险, 限令在一天内进行卸载. 在平常的一些 python 的项目中, anaconda 还是很方便的, 不同的项目管理不同的开发环境, 不过得合乎公司的规定, 所以只能通过其他的方式【命令】创建和管理虚拟环境了. 都是一些基础知识, 时间长没用, 做个记录.</p></blockquote><p><a href="https://www.anaconda.com/download/">anaconda</a></p><h1 id="使用-virtualenv-管理虚拟环境"><a href="#使用-virtualenv-管理虚拟环境" class="headerlink" title="使用 virtualenv 管理虚拟环境"></a>使用 virtualenv 管理虚拟环境</h1><p>由于项目需要, 需要同时具备 py2 和 py3, 所以在创建虚拟环境的时候需要指定 python 解释器</p><p>创建虚拟环境</p><p> <code>virtualenv env27 --python=python2.7</code></p><p>激活虚拟环境</p><ul><li>windows: <code>.\env27\Scripts\activate</code></li></ul><p>退出虚拟环境</p><ul><li>windows: <code>.\env27\Scripts\deactivate</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;平常使用 anaconda 对开发环境做管理, 公司某天发了一条通知, 说 anaconda 未经授权不许使用, 存在 xxx 风险, 限令在一天内进行卸载. 在平常的一些 python 的项目中, anaconda 还是很方便的, 不同的项目管理</summary>
      
    
    
    
    <category term="编程语言" scheme="https://champion-yang.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Python" scheme="https://champion-yang.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>kafka踩过的坑</title>
    <link href="https://champion-yang.github.io/2024/07/05/02_kafka/2024-07-05-kafka02/"/>
    <id>https://champion-yang.github.io/2024/07/05/02_kafka/2024-07-05-kafka02/</id>
    <published>2024-07-05T08:48:17.000Z</published>
    <updated>2024-07-09T09:46:59.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://cloud.tencent.com/developer/article/1799294">我用kafka两年踩过的一些非比寻常的坑</a></li><li><a href="https://www.szzdzhp.com/"></a><a href="https://www.szzdzhp.com/">https://www.szzdzhp.com/</a></li></ol><h1 id="python-kafka"><a href="#python-kafka" class="headerlink" title="python-kafka"></a>python-kafka</h1><blockquote><p>在 python2 下测试 <code>kafka-python==1.4.7</code></p></blockquote><p>安装<br> <code>pip2 install kafka-python==1.4.7</code></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><a href="https://blog.csdn.net/qq_16829085/article/details/108414433">使用 kafka-python 产生的错误</a></p><p> <code>ValueError: filedescriptor out of range in select()</code></p><p> <a href="https://blog.csdn.net/whatday/article/details/113771166">fd 超出 1024 导致的异常1</a><br> <a href="https://github.com/dpkp/kafka-python/issues/1952">fd 超出 1024 导致的异常2</a></p><p><img src="/../../images/kafka/01.png" alt="img"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="SimplePorducer"><a href="#SimplePorducer" class="headerlink" title="SimplePorducer"></a>SimplePorducer</h3><blockquote><p>send_messages接收多个发送消息, 用create_message_set打包成一个messages列表, messages传给ProduceRequestPayload创建一个payloads对象, 用payload对应的broker对payloads分组, 遍历这个分组每个分组发送一次, 用ProduceRequest对payload创建request对象, 用BrokerConnection对象发送request对象, 发送时使用的socket连接, 发送后返回一个future对象, 再用select.select监听这些连接, 当文件描述符超过1024时报错就是这时候发生的.client的创建类为KafkaClient, 基础类为SimpleClent</p></blockquote><blockquote><p>问题, select.select监听文件描述符报错, 文件描述符报错实际是在SimpleClent._send_broker_aware_request中产生, 可能的话可以重写_send_broker_aware_request方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaClient,SimpleProducer</span><br><span class="line">host = <span class="string">&#x27;10.8.100.7:9092&#x27;</span></span><br><span class="line">client = KafkaClient(host=host)</span><br><span class="line">producer = SimpleProducer(client=client)</span><br><span class="line">messages = [<span class="string">&#x27;messageA&#x27;</span>,<span class="string">&#x27;messageB&#x27;</span>]</span><br><span class="line">topic = <span class="string">&#x27;topic&#x27;</span></span><br><span class="line">producer.send_messages(topic,*messages)</span><br></pre></td></tr></table></figure><h3 id="KafkaProducer"><a href="#KafkaProducer" class="headerlink" title="KafkaProducer"></a>KafkaProducer</h3><blockquote><p>KafkaProducer通过send在代码逻辑上发送发送单条消息, 但是KafkaProducer实现了一个了一个线程, 通过send将消息发送到列表中, 在线程通过消费这个列表, 当消息满足batch_size个字符的数据的发送条件时, 会讲batch_size个字符的数据用socket发送给kafka, 发送完成会将连接放入_sending. 这个线程是一个循环调用run_once方法, 在run_once发送中调用发送逻辑, 发送完成后讲_sending中conn注册到kqueue中, 等待连接回调. 因为KafkaProducer使用的是kqueue, 所以不会碰到和SimpleProducer一样的问题.</p></blockquote><p>后线程的实现类是Sender, kafka连接类是BrokerConnection, kafka client类是client_async. KafkaClient, selector类是vendor&#x2F;selectors34.py. KqueueSelector</p><blockquote><p>问题:kafkaProducer当发送数据比较多时, 发送次数也会多, 当在django中请求比较少时, 发送到列表中数据也少, 发送一个请求发送到kafka中, 可能连续都完成了, </p></blockquote><p>发送很快, 当请求变多时, 发送到列表中的数据变的无序, 不一定属于那个哪个请求的哪一次kafka发送, 因此会导致请求的数据发送到kafka变慢.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line">host = <span class="string">&#x27;10.8.100.7:9092&#x27;</span></span><br><span class="line">producer = KafkaProducer(bootstrap_servers=host)</span><br><span class="line">messages = [<span class="string">&#x27;messageA&#x27;</span>,<span class="string">&#x27;messageB&#x27;</span>]</span><br><span class="line">topic = <span class="string">&#x27;topic&#x27;</span></span><br><span class="line"><span class="keyword">for</span> message <span class="keyword">in</span> messages:</span><br><span class="line">    producer.send(topic,messages)</span><br></pre></td></tr></table></figure><h1 id="kafka-消费的坑"><a href="#kafka-消费的坑" class="headerlink" title="kafka 消费的坑"></a>kafka 消费的坑</h1><p><a href="https://juejin.cn/post/7314509615159885875">kafka积压类问题</a><a href="https://juejin.cn/post/7314509615159885875">https://juejin.cn/post/7314509615159885875</a><br><a href="https://www.cnblogs.com/even160941/p/17010989.html">kafka如何处理大量积压消息</a><a href="https://www.cnblogs.com/even160941/p/17010989.html">https://www.cnblogs.com/even160941/p/17010989.html</a></p><h2 id="数据积压问题"><a href="#数据积压问题" class="headerlink" title="数据积压问题"></a>数据积压问题</h2><p>在大数据的场景下使用 MQ 一定会遇到数据积压的问题</p><p>Kafka消息积压的问题, 核心原因是生产太快、消费太慢, 处理速度长期失衡, 从而导致消息积压(Lag)的场景, 积压到超过队列长度限制, 就会出现还未被消费的数据产生丢失的场景.</p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>生产者异常导致重复生产数据, 需要考虑代码健壮性;<br>服务器的ACK级别设置为-1, 即 <code>At Least Once</code> 可以保证数据不丢失, 但是不能保证数据不重复; </p><p>处理方式:</p><ol><li>幂等性 <strong>Exactly Once</strong>，数据不会重复生产【0.11版本的kafka才会有的特性】</li><li>优化生产逻辑，做好监控预警功能</li></ol><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者业务流程复杂, 消费速率远远小于生产速录, 产生消息积压; 涉及到 IO 的交互和网络的交互, 比如数据库SQL执行慢, 调用其他系统的API慢等<br>总结有两方面原因:</p><ul><li>消费能力不足: 消费的慢, 逻辑问题</li><li>数据处理&#x2F;拉取能力不足:(拉取数据&#x2F;处理时间 &lt; 生产速度)</li></ul><p>第一种处理方式:</p><ol><li>对partition扩容增加partition数量</li><li>将消费者代码修改为多线程并发消费</li><li>提高单条消息的处理速度, 如: 优化业务流程, 增加缓存, 去掉耗时操作</li></ol><p>第二种处理方式:</p><p>max.poll.records &#x3D; 20, 而 max.poll.interval.ms &#x3D; 1000, 也就是说consumer一次最多拉取 20 条消息, 两次拉取的最长时间间隔为 1 秒.<br>也就是说消费者拉取的20条消息必须在1秒内处理完成, 紧接着拉取下一批消息. 否则, 超过1秒后, Kafka broker会认为该消费者处理太缓慢而将他踢出消费组, 从而导致消费组rebalance.<br>根据Kafka机制, 消费组rebalance过程中是不会消费消息的, 所以看到ip是B和C轮流拉取消息, 又轮流被踢出消费组, 消费组循环进行rebalance, 消费就堆积了</p><p>处理方案: 消费者客户端减小 max.poll.records 或 增加 max.poll.interval.ms . RD 将 max.poll.records 设置为 1, 重启消费者后消费恢复</p><h2 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1799294&quot;&gt;我用</summary>
      
    
    
    
    <category term="大数据" scheme="https://champion-yang.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Kafka" scheme="https://champion-yang.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka架构理解和基本概念</title>
    <link href="https://champion-yang.github.io/2024/07/05/02_kafka/2024-07-05-kafka01/"/>
    <id>https://champion-yang.github.io/2024/07/05/02_kafka/2024-07-05-kafka01/</id>
    <published>2024-07-05T08:26:02.000Z</published>
    <updated>2024-07-09T08:54:49.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h1><ol><li>解耦<br>允许你独立的扩展或修改两边的处理过程, 只要确保它们遵守同样的接口约束.</li><li>可恢复性<br>系统的一部分组件失效时, 不会影响到整个系统. 消息队列降低了进程间的耦合度, 所以即使一个处理<br>消息的进程挂掉, 加入队列中的消息仍然可以在系统恢复后被处理.</li><li>缓冲<br>有助于控制和优化数据流经过系统的速度, 解决生产消息和消费消息的处理速度不一致的情况.</li><li>灵活性与峰值处理能力<br>在访问量剧增的情况下, 应用仍然需要继续发挥作用, 但是这样的突发流量并不常见. 如果为以能处理<br>这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费. 使用消息队列能够使关键组件顶住突发的<br>访问压力, 而不会因为突发的超负荷的请求而完全崩溃.</li><li>异步通信<br>很多时候, 用户不想也不需要立即处理消息. 消息队列提供了异步处理机制, 允许用户把一个消息放入<br>队列, 但并不立即处理它. 想向队列中放入多少消息就放多少, 然后在需要的时候再去处理它们.</li></ol><h1 id="Kafka适合以下应用场景"><a href="#Kafka适合以下应用场景" class="headerlink" title="Kafka适合以下应用场景"></a>Kafka适合以下应用场景</h1><ol><li>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放<br>给各种consumer.</li><li>消息系统：解耦生产者和消费者、缓存消息等。</li><li>用户活动跟踪：kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击<br>等活动, 这些活动信息被各个服务器发布到kafka的topic中, 然后消费者通过订阅这些topic来做实<br>时的监控分析, 亦可保存到数据库.</li><li>运营指标：kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作<br>的集中反馈, 比如报警和报告; </li><li>流式处理：比如spark和flink。</li></ol><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li>Producer ：消息生产者，就是向kafka broker发消息的客户端。</li><li>Consumer ：消息消费者，向kafka broker取消息的客户端。</li><li>Consumer Group （CG）：消费者组，由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据, 一个分区只能由一个组内消费者消费; 消费者组之间互不影响. 所有的消费者都属于某个消费者组, 即<strong>消费者组是逻辑上的一个订阅者</strong>.</li><li>Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic.</li><li>Topic ：可以理解为一个队列，生产者和消费者面向的都是一个topic。</li><li>Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition, <strong>每个partition是一个有序的队列</strong>.</li><li>Replica：副本，为保证集群中的某个节点发生故障时，该节点上的partition数据不丢失，且kafka仍然能够继续工作, kafka提供了副本机制, 一个topic的每个分区都有若干个副本, 一个leader和若干个follower.</li><li>leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader.</li><li>follower：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时, 某个follower会成为新的follower.</li></ol><h1 id="kafka为什么要分区"><a href="#kafka为什么要分区" class="headerlink" title="kafka为什么要分区"></a>kafka为什么要分区</h1><ol><li>方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个<br>Partition组成, 因此整个集群就可以适应任意大小的数据了.</li><li>可以提高并发，因为可以以Partition为单位读写。</li></ol><h1 id="Kafka生产者分区策略"><a href="#Kafka生产者分区策略" class="headerlink" title="Kafka生产者分区策略"></a>Kafka生产者分区策略</h1><ol><li>指明 partition 的情况下，直接将指明的值直接作为partiton值。</li><li>没有指明partition值但有key的情况下，将key的hash值与topic的partition数进行取余得到<br>partition值.</li><li>既没有partition值又没有key值的情况下，第一次调用时随机生成一个整数(后面每次调用在这个<br>整数上自增), 将这个值与topic可用的partition总数取余得到partition值, 也就是常说的round-robin算法.</li></ol><h1 id="kafka的数据可靠性怎么保证"><a href="#kafka的数据可靠性怎么保证" class="headerlink" title="kafka的数据可靠性怎么保证"></a>kafka的数据可靠性怎么保证</h1><p>为保证producer发送的数据, 能可靠的发送到指定的topic, topic的每个partition收到producer发送的<br>数据后, 都需要向producer发送ack(acknowledgement确认收到), 如果producer收到ack, 就会进<br>行下一轮的发送, 否则重新发送数据. 所以引出ack机制.</p><h1 id="数据重复和丢失问题"><a href="#数据重复和丢失问题" class="headerlink" title="数据重复和丢失问题"></a>数据重复和丢失问题</h1><p>Kafka为用户提供了三种可靠性级别, 用户根据对可靠性和延迟的要求进行权衡, 选择以下的配置.</p><p>acks参数配置:</p><ul><li>0:producer不等待broker的ack, 这一操作提供了一个最低的延迟, broker一接收到还没有写入磁盘就已经返回, 当broker故障时有可能丢失数据.</li><li>1:producer等待broker的ack, partition的leader落盘成功后返回ack, 如果在follower同步成功之前leader故障, 那么将会丢失数据.</li><li>-1(all):producer等待broker的ack, partition的leader和follower全部落盘成功后才返回ack.<br>但是如果在follower同步完成后, broker发送ack之前, leader发生故障, 那么会造成数据重复.</li></ul><h1 id="Kafka消费能力不足怎么处理"><a href="#Kafka消费能力不足怎么处理" class="headerlink" title="Kafka消费能力不足怎么处理"></a>Kafka消费能力不足怎么处理</h1><ol><li>如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，<br>消费者数&#x3D;分区数.(两者缺一不可)</li><li>如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据&#x2F;处理时间&lt;<br>生产速度), 使处理的数据小于生产的数据, 也会造成数据积压.</li></ol><h1 id="Kafka中的数据是有序的吗"><a href="#Kafka中的数据是有序的吗" class="headerlink" title="Kafka中的数据是有序的吗"></a>Kafka中的数据是有序的吗</h1><p>单分区内有序.<br>多分区, 分区与分区间无序.</p><h1 id="Kafka可以按照时间消费数据吗"><a href="#Kafka可以按照时间消费数据吗" class="headerlink" title="Kafka可以按照时间消费数据吗"></a>Kafka可以按照时间消费数据吗</h1><p>可以, 提供的API方法:<br>KafkaUtil.fetchOffsetsWithTimestamp(topic, sTime, kafkaProp)</p><h1 id="Kafka单条日志传输大小"><a href="#Kafka单条日志传输大小" class="headerlink" title="Kafka单条日志传输大小"></a>Kafka单条日志传输大小</h1><p>kafka对于消息体的大小默认为单条最大值是1M但是在我们应用场景中, 常常会出现一条消息大于1M,<br>如果不对kafka进行配置. 则会出现生产者无法将消息推送到kafka或消费者无法去消费kafka里面的数<br>据, 这时我们就要对kafka进行以下配置:server.properties</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replica.fetch.max.bytes: 1048576 # broker可复制的消息的最大字节数, 默认为1M</span><br><span class="line">message.max.bytes: 1000012 # kafka 会接收单个消息size的最大限制， 默认为1M左右</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意 message.max.bytes必须小于等于replica.fetch.max.bytes，否则就会导致replica之间数据同步失败</span></span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://kafka1x.apachecn.org/">kafka官方中文文档</a> </li><li>公众号: 大数据左右手</li><li><a href="https://cloud.tencent.com/developer/article/1991788">超详细的Kafka教程-从部署到开发到原理都有讲解</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要用消息队列&quot;&gt;&lt;a href=&quot;#为什么要用消息队列&quot; class=&quot;headerlink&quot; title=&quot;为什么要用消息队列&quot;&gt;&lt;/a&gt;为什么要用消息队列&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;解耦&lt;br&gt;允许你独立的扩展或修改两边的处理过程, 只要确保它们遵守同样</summary>
      
    
    
    
    <category term="大数据" scheme="https://champion-yang.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Kafka" scheme="https://champion-yang.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>2024-07-04-pandas03</title>
    <link href="https://champion-yang.github.io/2024/07/04/01_pandas/2024-07-04-pandas03/"/>
    <id>https://champion-yang.github.io/2024/07/04/01_pandas/2024-07-04-pandas03/</id>
    <published>2024-07-04T07:33:47.000Z</published>
    <updated>2024-07-04T08:41:53.015Z</updated>
    
    
    
    
    <category term="数据科学" scheme="https://champion-yang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据处理" scheme="https://champion-yang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>2024-07-04-pandas02</title>
    <link href="https://champion-yang.github.io/2024/07/04/01_pandas/2024-07-04-pandas02/"/>
    <id>https://champion-yang.github.io/2024/07/04/01_pandas/2024-07-04-pandas02/</id>
    <published>2024-07-04T07:29:31.000Z</published>
    <updated>2024-07-04T08:41:38.030Z</updated>
    
    
    
    
    <category term="数据科学" scheme="https://champion-yang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据处理" scheme="https://champion-yang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="Pandas" scheme="https://champion-yang.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>研发工程视角下的数据分析(数据处理)</title>
    <link href="https://champion-yang.github.io/2024/07/04/01_pandas/2024-07-04-pandas01/"/>
    <id>https://champion-yang.github.io/2024/07/04/01_pandas/2024-07-04-pandas01/</id>
    <published>2024-07-04T06:06:55.000Z</published>
    <updated>2024-07-08T03:02:55.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在大数据时代的背景下, 数据已经成为企业中最重要的资产和生产要素. 如何从数据中发现并挖掘有价值的信息则显得尤为重要. 在项目交付过程中, 数据是平台&#x2F;xx系统的基础, 而作为研发人员经常会面对客户的提数需求, 这部分需求经常具备个性化、临时性、一次性等特点. 如下作为示例:</p><ul><li>产品需求: 系统上线后数据异常原因排查; 新老版本数据融合需求; 数据报表需求等</li><li>运营需求: 某次任务关联的报告数据; 通过系统数据做趋势预测; 数据变动的原因分析等</li><li>客户需求: 提取某次数据上报过程中某省单位的上报详情并出具分析报告; 查一下某个时间点下系统数据的合规率等<br>本系列的文章介绍的数据分析区别于BI工程师【数据分析师】的数据分析, 现实情况中BI们往往在做业务方最关心的数据、最关心的问题等方向的分析, 对于日常过程中的个性化、临时性的数分需求, 一般都是通过研发工程师进行实现. 本系列文章的重点将会以研发工程师【非BI】的视角出发, 介绍如何通过 Python 快速进行数据分析.</li></ul><h1 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h1><p>知其然, 需知其所以然. 数据科学是一门复杂的学科, 包括了统计学、数据分析、机器学习在内的多种学科方法, 而数据分析则关注在现有的数据集中, 执行和处理统计分析. 体系化的了解数据分析的流程, 是做数据分析的前置条件.<br>常规的数据分析流程如下:</p><p><img src="/../../images/pandas/01.png" alt="img"></p><ul><li>明确分析思路和目的: 我们接到一个分析任务, 首先要弄清楚我们分析的对象是什么, 要达成怎样的目的, 不能陷于为了分析而分析. 然后, 要熟悉行业和业务, 透彻的理解分析的目的, 构建起分析的角度和体系.</li><li>数据收集: 按照确定的数据分析的思路和框架, 进行数据收集和整合.</li><li>数据处理: 对收集到的数据进行清洗、加工、整理等</li><li>数据分析: 通过分析手段、方法和技巧等对准备好的数据进行探索分析, 从中发现数据的规律.</li><li>数据展现: 通过图表或者报告的形式进行数据到的展现.</li></ul><h1 id="从研发视角看数据分析【数据处理篇】"><a href="#从研发视角看数据分析【数据处理篇】" class="headerlink" title="从研发视角看数据分析【数据处理篇】"></a>从研发视角看数据分析【数据处理篇】</h1><p>作为研发工程师, 在常规的项目中, 假定我们现在接收到的临时性的提数需求已经和产品经理&#x2F;项目经理就数分的思路和目的达成了一致, 并且系统中的数据已经通过南向接口或其他方式进行了收集, 下一步要展开数据处理过程.<br>数据清洗是数据预处理的第一步, 主要是为了解决数据中的缺失值、异常值、重复值等问题. Python提供了pandas库可以帮助我们方便地处理源数据中的缺失值、重复值和异常值, 数据处理可以极大的提升数据的质量, 只有经过处理的数据才可以作为下一步数据分析模型的输入.<br>pandas常用的基本功能如下:</p><ul><li>从Excel、CSV、网页、SQL、剪贴板等文件或工具中读取数据; </li><li>合并多个文件或者电子表格中的数据, 将数据拆分为独立文件; </li><li>数据清洗, 如去重、处理缺失值、填充默认值、补全格式、处理极端值等; </li><li>建立高效的索引; </li><li>支持大体量数据; </li><li>按一定业务逻辑插入计算后的列、删除列; </li><li>灵活方便的数据查询、筛选; </li><li>分组聚合数据, 可独立指定分组后的各字段计算方式; </li><li>数据的转置, 如行转列、列转行变更处理; </li><li>连接数据库, 直接用SQL查询数据并进行处理; </li><li>对时序数据进行分组采样, 如按季、按月、按工作小时, 也可以自定义周期, 如工作日; </li><li>窗口计算, 移动窗口统计、日期移动等; </li><li>灵活的可视化图表输出, 支持所有的统计图形; </li><li>为数据表格增加展示样式, 提高数据识别效率.</li></ul><h1 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure><h3 id="数据集分析"><a href="#数据集分析" class="headerlink" title="数据集分析"></a>数据集分析</h3><p>在准备员工一到四月的考核结果表, 各列说明如下:</p><ul><li>name: 员工的姓名, 这列没有重复值, 一个员工一行</li><li>team: 所在的团队, 这个数据会重复</li><li>一月～四月: 各个月份的考核结果, 可能会有重复值, 缺失值, 异常值</li></ul><img src="/images/pandas/02.png"   style="zoom:20%; " /><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><h4 id="检查是否有缺失值"><a href="#检查是否有缺失值" class="headerlink" title="检查是否有缺失值"></a>检查是否有缺失值</h4><p>关键技术: isnull()方法返回值为布尔值, 如果数据存在缺失值, 返回True; 否则, 返回False.</p><img src=/images/pandas/03.png   style="zoom:20%; " /><p>经查, 原始数据中具备缺失值.</p><h4 id="需求案例A-如果该行具有缺失值-则这一行数据被丢弃"><a href="#需求案例A-如果该行具有缺失值-则这一行数据被丢弃" class="headerlink" title="需求案例A: 如果该行具有缺失值, 则这一行数据被丢弃"></a>需求案例A: 如果该行具有缺失值, 则这一行数据被丢弃</h4><p>关键技术: dropna()用于删除含有缺失值的行.</p><img src=/images/pandas/04.png   style="zoom:20%; " /><h4 id="需求案例B-如果该行具有缺失值-则缺失的值使用平均值进行填充"><a href="#需求案例B-如果该行具有缺失值-则缺失的值使用平均值进行填充" class="headerlink" title="需求案例B: 如果该行具有缺失值, 则缺失的值使用平均值进行填充"></a>需求案例B: 如果该行具有缺失值, 则缺失的值使用平均值进行填充</h4><p>关键技术: fillna()方法用于填充含有缺失值的行.mean()方法用于求改行的平均值.</p><img src=/images/pandas/05.png   style="zoom:20%; " /><h3 id="重复值处理"><a href="#重复值处理" class="headerlink" title="重复值处理"></a>重复值处理</h3><h4 id="检查是否有重复值"><a href="#检查是否有重复值" class="headerlink" title="检查是否有重复值"></a>检查是否有重复值</h4><p>关键技术: duplicated()方法检测冗余的行或列, 默认是判断全部列中的值是否全部重复, 并返回布尔类型的结果. 对于完全没有重复的行, 返回值为False. 对于有重复值的行, 第一次出现重复的那一行返回False, 其余的返回True.</p><img src=/images/pandas/06.png   style="zoom:20%; " /><h4 id="需求案例C-如果该行有重复值则丢弃该行数据"><a href="#需求案例C-如果该行有重复值则丢弃该行数据" class="headerlink" title="需求案例C: 如果该行有重复值则丢弃该行数据"></a>需求案例C: 如果该行有重复值则丢弃该行数据</h4><p>关键技术: drop_duplicates()删除重复的行.</p><img src=/images/pandas/07.png   style="zoom:20%; " /><h3 id="异常值检测和处理"><a href="#异常值检测和处理" class="headerlink" title="异常值检测和处理"></a>异常值检测和处理</h3><h4 id="检查是否有异常值"><a href="#检查是否有异常值" class="headerlink" title="检查是否有异常值"></a>检查是否有异常值</h4><p>关键技术:query()方法查询数据中是否有异常值, 用于在 DataFrame 中执行类似于 SQL 的查询的工具, 支持简单查询, 逻辑运算查询, 字符串查询等.</p><img src=/images/pandas/08.png   style="zoom:20%; " /><h3 id="输出新的文件"><a href="#输出新的文件" class="headerlink" title="输出新的文件"></a>输出新的文件</h3><h4 id="需求案例D-根据描述输出报告"><a href="#需求案例D-根据描述输出报告" class="headerlink" title="需求案例D: 根据描述输出报告"></a>需求案例D: 根据描述输出报告</h4><p>需求描述: 将原始数据根据姓名进行分组, 缺失值和异常值默认按照0进行统计, 计算每个人的平均分并从大到小进行排序, 输出内容到 excel.<br>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入Pandas库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取excel内容</span></span><br><span class="line"></span><br><span class="line">df = pd.read_excel(<span class="string">&quot;./数据集/team.xlsx&quot;</span>, )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 0 填充缺失值</span></span><br><span class="line"></span><br><span class="line">df = df.fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除重复的行</span></span><br><span class="line"></span><br><span class="line">df = df.drop_duplicates().copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺失值和异常值默认按照0进行填充</span></span><br><span class="line"></span><br><span class="line">df[[<span class="string">&quot;一月&quot;</span>, <span class="string">&quot;二月&quot;</span>, <span class="string">&quot;三月&quot;</span>, <span class="string">&quot;四月&quot;</span>]] = df[[<span class="string">&quot;一月&quot;</span>, <span class="string">&quot;二月&quot;</span>, <span class="string">&quot;三月&quot;</span>, <span class="string">&quot;四月&quot;</span>]].applymap(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x &gt; <span class="number">100</span> <span class="keyword">or</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一列, 平均值</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;平均值&#x27;</span>] = df[[<span class="string">&quot;一月&quot;</span>, <span class="string">&quot;二月&quot;</span>, <span class="string">&quot;三月&quot;</span>, <span class="string">&quot;四月&quot;</span>]].mean(axis=<span class="number">1</span>).<span class="built_in">round</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照平均值排序</span></span><br><span class="line"></span><br><span class="line">df = df.sort_values([<span class="string">&#x27;平均值&#x27;</span>], ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据输出到Excel文件中</span></span><br><span class="line"></span><br><span class="line">df.to_excel(<span class="string">&#x27;./output.xlsx&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>输出的excel结果如下:</p><img src=/images/pandas/09.png   style="zoom:20%; " /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单介绍了数据分析的流程以及如何做数据的预处理. 利用几个示例对工作中常见的操作进行了说明, 从代码的层面可以看出, 利用 Python 进行数据分析的操作会更加的灵活快捷方便, 尤其是在临时性的需求面前, 会大大节约我们的时间和资源成本.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在大数据时代的背景下, 数据已经成为企业中最重要的资产和生产要素. 如何从数据中发现并挖掘有价值的信息则显得尤为重要. 在项目交付过程中, </summary>
      
    
    
    
    <category term="数据科学" scheme="https://champion-yang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据处理" scheme="https://champion-yang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="Pandas" scheme="https://champion-yang.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>备考系统架构师</title>
    <link href="https://champion-yang.github.io/2024/07/04/%E5%A4%87%E8%80%83%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    <id>https://champion-yang.github.io/2024/07/04/%E5%A4%87%E8%80%83%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/</id>
    <published>2024-07-04T01:31:28.000Z</published>
    <updated>2024-07-04T08:43:13.335Z</updated>
    
    
    
    
    <category term="系统架构师" scheme="https://champion-yang.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
    
    <category term="架构" scheme="https://champion-yang.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>明朝那些事</title>
    <link href="https://champion-yang.github.io/2024/07/04/%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>https://champion-yang.github.io/2024/07/04/%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2024-07-04T01:31:28.000Z</published>
    <updated>2024-07-04T08:43:26.683Z</updated>
    
    <content type="html"><![CDATA[<p>这是测试信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是测试信息&lt;/p&gt;
</summary>
      
    
    
    
    <category term="读书" scheme="https://champion-yang.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="书籍" scheme="https://champion-yang.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>探究Docker镜像</title>
    <link href="https://champion-yang.github.io/2024/07/02/%E6%8E%A2%E7%A9%B6Docker%E9%95%9C%E5%83%8F/"/>
    <id>https://champion-yang.github.io/2024/07/02/%E6%8E%A2%E7%A9%B6Docker%E9%95%9C%E5%83%8F/</id>
    <published>2024-07-02T07:32:45.000Z</published>
    <updated>2024-07-04T08:43:18.695Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#docker%E9%95%9C%E5%83%8F%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">Docker镜像简单介绍</a><ul><li><a href="#%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%9C%E5%83%8F">到底什么是镜像?</a></li><li><a href="#%E9%95%9C%E5%83%8F%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84">镜像是用来干嘛的?</a></li><li><a href="#%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E6%88%90%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">镜像的构成是怎样的?</a></li></ul></li><li><a href="#docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8">Docker镜像使用</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F">获取镜像</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F">查看镜像</a></li><li><a href="#%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F">运行镜像</a></li><li><a href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F">删除镜像</a></li><li><a href="#%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F">定制镜像</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F">构建镜像的其他方式</a></li></ul></li></ul><!-- /code_chunk_output --><h1 id="Docker镜像简单介绍"><a href="#Docker镜像简单介绍" class="headerlink" title="Docker镜像简单介绍"></a>Docker镜像简单介绍</h1><p>要知道Docker镜像是怎么一回事, 得先知道Docker是怎么一回事:<br>Docker 是一个开源的、轻量级的容器引擎, 主要运行于 Linux 和 Windows, 用于创建、管理和编排容器. 为了让应用程序既可以运行在统一主机或者集群, 又能彼此隔离, 虚拟机出现了. 但是虚拟机需要自己的操作系统, 一般体积比较庞大不好维护和升级, 所以容器出现了. 容器目的就是运行应用或者服务, 这意味着容器的镜像中必须包含应用&#x2F;服务运行所必需的操作系统和应用文件.</p><p>ok, 进入主题!</p><h2 id="到底什么是镜像"><a href="#到底什么是镜像" class="headerlink" title="到底什么是镜像?"></a>到底什么是镜像?</h2><p>我们都知道操作系统分为内核和用户空间, 对于 Linux 而言, 内核启动后会挂在 root 文件系统为其提供用户空间的支持. 而 Docker 镜像 就相当于一个 root 文件系统, 提供容器运行时所需的程序、库、资源、配置等文件以及运行时的参数(环境变量、用户、数据卷等).</p><h2 id="镜像是用来干嘛的"><a href="#镜像是用来干嘛的" class="headerlink" title="镜像是用来干嘛的?"></a>镜像是用来干嘛的?</h2><p>docker 镜像代表了容器的文件系统里的内容, 是容器的基础, 镜像一般是通过 Dockerfile 生成的, 容器是镜像运行时的实体.</p><h2 id="镜像的构成是怎样的"><a href="#镜像的构成是怎样的" class="headerlink" title="镜像的构成是怎样的?"></a>镜像的构成是怎样的?</h2><p>在 Docker 的设计上采用了 Union FS 的技术, 分层存储的架构. 所以严格意义上来讲镜像是一个虚拟的概念, 其体现并非由一个文件组成, 而是由一组文件系统组成, 或者说是由多层文件系统联合组成.<br>简单理解, docker 的镜像是分层的, 所有的镜像(除了基础镜像)都是在之前镜像的基础上加上自己这层的内容生成的.</p><h1 id="Docker镜像使用"><a href="#Docker镜像使用" class="headerlink" title="Docker镜像使用"></a>Docker镜像使用</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>镜像构建完成后, 我们可以将其上传到仓库中, 供由其他服务器使用. 提供集中存储和分发镜像的服务是 Docker Registry, 官方发布的公开服务地址是 <a href="https://hub.docker.com/">https://hub.docker.com/</a>, 国内也有云服务商发布类似公开的服务, 比如阿里云 <a href="https://cn.aliyun.com/product/acr?source=5176.11533457&userCode=8lx5zmtu">https://cn.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu</a><br>除了使用公开服务外, 我们还可以在本地搭建私有的 Docker Registry.</p><p>通过命令 docker pull 从仓库获取镜像, 不指定 Docker Registry 默认从 docker hub 拉取镜像. 如图我们以拉取 mysql5.6 镜像为例:</p><p> <code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></p><p><img src="/../images/docker/image01.png" alt="image" title="xxx"></p><h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><p>使用 docker image ls 命令查看所有已经下载的镜像, 如下图所示可以看到我们下载的 mysql5.6 镜像.</p><p> <code>docker image ls</code></p><p>通过 <code>docker image ls mysql</code> 命令可以查看指定名称的镜像</p><p> <code>docker image ls mysql</code></p><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p> <code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:5.6</code></p><p>查看运行中的容器:<br> <code>docker ps</code></p><p>进入容器内部:<br> <code>docker exec -it b22754ecb0a9 /bin/bash</code></p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p> <code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></p><p>其中, &lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要等.<br>像其它可以承接多个实体的命令一样, 可以使用 docker image ls -q  来配合使用 docker image rm, 这样可以成批的删除希望删除的镜像.<br> <code>docker image rm $(docker image ls -q mysql)</code></p><h2 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h2><p>镜像构建时, 会一层层构建, 前一层是后一层的基础. 每一层构建完就不会再发生改变, 后一层上的任何改变只发生在自己这一层. 比如, 删除前一层文件的操作, 实际不是真的删除前一层的文件, 而是仅在当前层标记为该文件已删除. 在最终容器运行的时候, 虽然不会看到这个文件, 但是实际上该文件会一直跟随镜像. 因此, 在构建镜像的时候, 需要额外小心, 每一层尽量只包含该层需要添加的东西, 任何额外的东西应该在该层构建结束前清理掉.<br>镜像的定制实际上就是定制每一层所添加的配置、文件. 如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本, 用这个脚本来构建、定制镜像, 那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决. 这个脚本就是 Dockerfile.</p><p>以定制 nginx 镜像为例:</p><ol><li>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile</li><li>Dockerfile 内写入以下内容</li></ol><p><code>FROM nginx RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></p><ol start="3"><li>构建 nginx 镜像</li></ol><p> <code>docker build -t nginx:v3 .</code></p><ol start="4"><li>在 9529 端口运行 nginx 镜像</li></ol><p> <code>docker run --name webserver -d -p 9529:80 nginx:v3</code></p><ol start="5"><li>开放 9529 端口可以被外部访问</li></ol><p> <code>iptables -I INPUT -p tcp --dport 9529 -j ACCEPT;</code></p><ol start="6"><li>浏览器访问该地址，得到返回 “Hello, Docker!”</li></ol><p>在示例中, 我们编写的 Dockerfile 文件很简单, 只有两条指令::</p><ul><li>FROM nginx ——&gt; 指定基础镜像, 定制镜像一定是以一个镜像为基础, 在其上进行定制. 在 Dockerfile 中 FROM 是必备的指令.</li><li>RUN xxx ——&gt; RUN 指令用来执行命令行命令.</li></ul><p>从对下图的分析诠释在 Dockerfile 中, 每一个指令都会建立一层的概念:<br>在 step1 中 FROM 指定拉取仓库中的 nginx 并提交了最新的一层 605c77e624dd.<br>在 step2 中 RUN 指令 开启了容器 d25b52a4b879 , 执行了 echo 的命令将银行中的内容覆盖输出到 nginx 目录下的 index.html 文件中, 然后删除了该容器 d25b52a4b879, 并最后提交了一层  b3db9b911471 .</p><p><img src="/../images/docker/image02.png" alt="image" title="xxx"></p><h2 id="构建镜像的其他方式"><a href="#构建镜像的其他方式" class="headerlink" title="构建镜像的其他方式"></a>构建镜像的其他方式</h2><p>除却使用 Dockerfile 生成镜像的方式, 我们还可以通过其他方式构建:</p><ol><li>从 rootfs 压缩包导入。</li></ol><p> <code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p><p>压缩包可以是本地文件、远程 Web 文件, 甚至是从标准输入中得到. 压缩包将会在镜像目录展开, 并直接作为镜像第一层提交.</p><ol start="2"><li>将构建好的 docker 镜像直接导入导出</li></ol><p>docker 提供了 docker save 和 docker load 命令, 用以将镜像保存为一个文件, 然后传输到另一个位置上, 再进行加载.</p><p> <code>docker save nginx:v3 | gzip &gt; nginx-v3.tar.gz</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#docker%E9%95%9C</summary>
      
    
    
    
    <category term="技术" scheme="https://champion-yang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="https://champion-yang.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Mac 通过 brew 安装 redis, 搭建 redis 集群</title>
    <link href="https://champion-yang.github.io/2024/07/01/Mac%20%E9%80%9A%E8%BF%87%20brew%20%E5%AE%89%E8%A3%85%20redis%EF%BC%8C%E6%90%AD%E5%BB%BA%20redis%20%E9%9B%86%E7%BE%A4/"/>
    <id>https://champion-yang.github.io/2024/07/01/Mac%20%E9%80%9A%E8%BF%87%20brew%20%E5%AE%89%E8%A3%85%20redis%EF%BC%8C%E6%90%AD%E5%BB%BA%20redis%20%E9%9B%86%E7%BE%A4/</id>
    <published>2024-07-01T10:05:47.000Z</published>
    <updated>2024-07-04T08:37:38.486Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#%E4%B8%80%E5%AF%B9%E9%9B%86%E7%BE%A4%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3">一、对集群的初步了解</a></li><li><a href="#%E4%BA%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4">二、为什么要搭建集群</a></li><li><a href="#%E4%B8%89%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA-redis-%E9%9B%86%E7%BE%A4">三、如何搭建 redis 集群</a><ul><li><a href="#1redis-%E5%AE%89%E8%A3%85-%E6%9F%A5%E7%9C%8Bredis%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84">1.redis 安装, 查看redis安装路径</a></li><li><a href="#2-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2. 集群环境配置</a></li></ul></li><li><a href="#%E5%9B%9B%E6%B5%8B%E8%AF%95">四、测试</a></li><li><a href="#%E4%BA%94%E7%9F%A5%E8%AF%86%E7%82%B9">五、知识点</a></li><li><a href="#%E5%85%AD%E5%8F%82%E8%80%83">六、参考</a></li></ul><!-- /code_chunk_output --><p>本篇通过灵魂三问来探究 redis 集群:</p><ul><li>是什么?</li><li>为什么?</li><li>怎么做?</li></ul><h2 id="一、对集群的初步了解"><a href="#一、对集群的初步了解" class="headerlink" title="一、对集群的初步了解"></a>一、对集群的初步了解</h2><p>todo…</p><h2 id="二、为什么要搭建集群"><a href="#二、为什么要搭建集群" class="headerlink" title="二、为什么要搭建集群"></a>二、为什么要搭建集群</h2><p>todo…</p><h2 id="三、如何搭建-redis-集群"><a href="#三、如何搭建-redis-集群" class="headerlink" title="三、如何搭建 redis 集群"></a>三、如何搭建 redis 集群</h2><h3 id="1-redis-安装-查看redis安装路径"><a href="#1-redis-安装-查看redis安装路径" class="headerlink" title="1.redis 安装, 查看redis安装路径"></a>1.redis 安装, 查看redis安装路径</h3><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><ul><li>redis.conf 路径:&#x2F;opt&#x2F;homebrew&#x2F;etc&#x2F;redis.conf</li></ul><p>ps: 这里路径及查找比较麻烦, </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/homebrew/Cellar/redis/7.0.4/homebrew.mxcl.redis.plist</span><br></pre></td></tr></table></figure><p><img src="/../images/redis/redis01.png" alt="image" title="xxx"></p><h3 id="2-集群环境配置"><a href="#2-集群环境配置" class="headerlink" title="2. 集群环境配置"></a>2. 集群环境配置</h3><ul><li>mkdir 以下目录,</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/homebrew/etc/redis.conf /usr/local/etc/redis/cluster/7000/7000.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------- 修改 7000.conf ，其他文件类似 ----------</span><br><span class="line">port 7000                                     # Redis 节点的端口号</span><br><span class="line">cluster-enabled yes                           # 实例以集群模式运行</span><br><span class="line">cluster-config-file nodes-7000.conf           # 节点配置文件路径</span><br><span class="line">cluster-node-timeout 5000                     # 节点间通信的超时时间</span><br><span class="line">appendonly yes                                # 数据持久化</span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure><p>集群目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc</span><br><span class="line">`-- redis</span><br><span class="line">    `-- cluster</span><br><span class="line">        |-- 7000</span><br><span class="line">        |   `-- 7000.conf</span><br><span class="line">        |-- 7001</span><br><span class="line">        |   `-- 7001.conf</span><br><span class="line">        |-- 7002</span><br><span class="line">        |   `-- 7002.conf</span><br><span class="line">        |-- 7003</span><br><span class="line">        |   `-- 7003.conf</span><br><span class="line">        |-- 7004</span><br><span class="line">        |   `-- 7004.conf</span><br><span class="line">        `-- 7005</span><br><span class="line">            `-- 7005.conf</span><br></pre></td></tr></table></figure><p>启动 redis 的六个节点:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/etc/redis/cluster/7000/7000.conf &amp;</span><br><span class="line">redis-server /usr/local/etc/redis/cluster/7001/7001.conf &amp;</span><br><span class="line">其他依次顺延</span><br></pre></td></tr></table></figure><p>查看启动状态:</p><p><img src="/../images/redis/redis02.png" alt="image" title="xxx"></p><p>查看版本号:<br>1、启动服务端:redis-server<br>2、启动客户端:redis-cli<br>3、客户端输入:info</p><p>创建集群(redis 5 和redis 7 创建集群的命令不一致, 示例是 redis 7)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create  --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure><p><img src="/../images/redis/redis03.png" alt="image" title="xxx"></p><p>warning: 不要将主从数据库放在同一台机器上, 避免宕机数据丢失<br>M:master 主节点<br>S:slave 从节点<br>三主三从<br>7000\7001\7002 主节点<br>7003、7004、7005 从节点</p><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p><img src="/../images/redis/redis04.png" alt="image" title="xxx"></p><p>集群搭建成功</p><p>下线一个主节点:</p><p><img src="/../images/redis/redis05.png" alt="image" title="xxx"></p><p>查看节点状态:</p><p><img src="/../images/redis/redis06.png" alt="image" title="xxx"></p><p>这个时间 7002 节点是 fail 状态, 并且 7004 成为了新的 master 节点</p><p>下线一个从节点 7005</p><p><img src="/../images/redis/redis07.png" alt="image" title="xxx"></p><p><img src="/../images/redis/redis08.png" alt="image" title="xxx"></p><p>上线一个从节点 7005</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/etc/redis/cluster/7005/7005.conf &amp;</span><br></pre></td></tr></table></figure><p><img src="/../images/redis/redis09.png" alt="image" title="xxx"></p><p>上线一个主节点 7002<br>这个时候已经有三个主节点了</p><p><img src="/../images/redis/redis10.png" alt="image" title="xxx"></p><p>这个时候 7002 上线成功, 不过成为了 从节点</p><h2 id="五、知识点"><a href="#五、知识点" class="headerlink" title="五、知识点"></a>五、知识点</h2><p>集群节点状态说明</p><ul><li>主节点<ul><li><p>主节点存在hash slots, 且主节点的hash slots 没有交叉<br>主节点不能删除</p></li><li><p>一个主节点可以有多个从节点</p></li><li><p>主节点宕机时多个副本之间自动选举主节点</p></li></ul></li><li>从节点<ul><li>从节点没有hash slots</li><li>从节点可以删除</li></ul></li></ul><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="https://segmentfault.com/a/1190000022808576%E3%80%8C%E5%BF%85%E7%9C%8B%E3%80%8D">https://segmentfault.com/a/1190000022808576「必看」</a></p><p><a href="http://redisdoc.com/topic/cluster-tutorial.html#id2%E3%80%8C%E5%BF%85%E7%9C%8B%E3%80%8D">http://redisdoc.com/topic/cluster-tutorial.html#id2「必看」</a></p><p><a href="https://blog.csdn.net/qq_43439968/article/details/109882660">https://blog.csdn.net/qq_43439968/article/details/109882660</a> </p><p><a href="https://zhuanlan.zhihu.com/p/59172042">https://zhuanlan.zhihu.com/p/59172042</a></p><p><a href="https://blog.csdn.net/qq_29329241/article/details/113326613">https://blog.csdn.net/qq_29329241/article/details/113326613</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E5%AF</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://champion-yang.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存一致性</title>
    <link href="https://champion-yang.github.io/2024/07/01/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://champion-yang.github.io/2024/07/01/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2024-07-01T09:55:31.000Z</published>
    <updated>2024-07-04T08:43:08.179Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#redis-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7">redis 缓存一致性</a><ul><li><a href="#%E4%B8%80%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%BE%E8%AE%A1">一、缓存的设计</a></li><li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%BA%E7%8E%B0">二、数据一致性问题的出现</a></li><li><a href="#%E4%B8%89%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">三、缓存一致性的解决思路</a><ul><li><a href="#1-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E5%85%88%E6%9B%B4%E6%96%B0-db-%E5%90%8E%E5%88%A0%E9%99%A4-cache">1. 常用方法: 先更新 db, 后删除 cache</a></li><li><a href="#2-%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99-%E5%90%8E%E5%88%A0%E7%BC%93%E5%AD%98%E8%BF%98%E6%98%AF%E5%AD%98%E5%9C%A8%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%BD%92%E6%A0%B9%E7%BB%93%E5%BA%95%E8%BF%98%E6%98%AF%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%8F%91%E7%94%9F%E5%9C%A8%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D">2. 高并发的时候, 后删缓存还是存在缓存不一致的问题(归根结底还是”删除操作”发生在”更新操作”之前)</a></li></ul></li><li><a href="#%E5%9B%9B%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98">四、缓存击穿问题</a></li></ul></li></ul><!-- /code_chunk_output --><h1 id="redis-缓存一致性"><a href="#redis-缓存一致性" class="headerlink" title="redis 缓存一致性"></a>redis 缓存一致性</h1><p>在项目中发现大家使用 redis 缓存, 不太注重一致性的设计, 所以整理本文, 希望能给大家一些帮助</p><img src="/2024/07/01/redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/image.png" class="" title="xxx"><h2 id="一、缓存的设计"><a href="#一、缓存的设计" class="headerlink" title="一、缓存的设计"></a>一、缓存的设计</h2><p>首先, 读缓存;<br>如果缓存里没有值, 那就读取数据库的值;<br>同时把这个值写进缓存中.</p><h2 id="二、数据一致性问题的出现"><a href="#二、数据一致性问题的出现" class="headerlink" title="二、数据一致性问题的出现"></a>二、数据一致性问题的出现</h2><p>双更新模式: 操作不合理, 导致数据一致性问题</p><p>比如我要更新一个值, 首先刷了缓存, 然后把数据库也更新了. 但过程中, 更新数据库可能会失败, 发生了回滚. 所以, 最后”缓存里的数据”和”数据库的数据”就不一样了, 也就是出现了数据一致性问题.</p><p>你或许会说: 我先更新数据库, 再更新缓存不就行了?</p><p>这依然会有问题.</p><p>考虑到下面的场景: 操作 A 更新 a 的值为 1, 操作 B 更新 a 的值为 2. 由于数据库和 Redis 的操作, 并不是原子的, 它们的执行时长也不是可控制的. 当两个请求的时序发生了错乱, 就会发生缓存不一致的情况.</p><h2 id="三、缓存一致性的解决思路"><a href="#三、缓存一致性的解决思路" class="headerlink" title="三、缓存一致性的解决思路"></a>三、缓存一致性的解决思路</h2><h3 id="1-常用方法-先更新-db-后删除-cache"><a href="#1-常用方法-先更新-db-后删除-cache" class="headerlink" title="1. 常用方法: 先更新 db, 后删除 cache"></a>1. 常用方法: 先更新 db, 后删除 cache</h3><p>数据的读取过程, 规则是”先读 cache, 再读 db”, 详细步骤如下:</p><ul><li>每次读取数据, 都从 cache 里读; </li><li>如果读到了, 则直接返回, 称作 cache hit; </li><li>如果读不到 cache 的数据, 则从 db 里面捞一份, 称作 cache miss; </li><li>将读取到的数据塞入到缓存中, 下次读取时, 就可以直接命中.</li></ul><p>写请求, 规则是”先更新 db, 再删除缓存”, 详细步骤如下:</p><ul><li>将变更写入到数据库中; </li><li>删除缓存里对应的数据.</li></ul><h3 id="2-高并发的时候-后删缓存还是存在缓存不一致的问题-归根结底还是”删除操作”发生在”更新操作”之前"><a href="#2-高并发的时候-后删缓存还是存在缓存不一致的问题-归根结底还是”删除操作”发生在”更新操作”之前" class="headerlink" title="2. 高并发的时候, 后删缓存还是存在缓存不一致的问题(归根结底还是”删除操作”发生在”更新操作”之前)"></a>2. 高并发的时候, 后删缓存还是存在缓存不一致的问题(归根结底还是”删除操作”发生在”更新操作”之前)</h3><p>解决方案:</p><ul><li><p>延时双删: 而假如我有一种机制, 能够确保删除动作一定被执行, 那就可以解决问题, 起码能缩小数据不一致的时间窗口. 常用的方法就是延时双删, 依然是先更新再删除, 唯一不同的是: 我们把这个删除动作, 在不久之后再执行一次, 比如 5 秒之后. 这种方案需要经过技术选型, 跟着项目走, 可以利用 mq, 延时队列等.</p></li><li><p>闪电缓存: 把缓存的失效时间设置非常短, 比如 3～4 秒. 一旦失效, 就会再次去数据库读取最新数据到缓存. 但这种方式, 在非常高的并发下, 同一时间对某个 key 的请求击穿到 DB, 会锁死数据库, 所以很少用.</p></li></ul><h2 id="四、缓存击穿问题"><a href="#四、缓存击穿问题" class="headerlink" title="四、缓存击穿问题"></a>四、缓存击穿问题</h2><p>缓存击穿, 指的是缓存中没有数据但数据库中有, 由于同一时刻请求量特别大, 但是没有读到缓存数据, 就会一股脑涌入到数据库中读取, 造成数据库假死.</p><p>任何删除缓存的动作都会造成缓存击穿.</p><p>所以我们上面一直说的是要删除缓存, 但在极高并发下, 你还不能乱删.<br>那么该问题如何解决呢?</p><ul><li>读操作互斥</li><li>集中更新</li><li>弱化数据库</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#redis-%E7%BC%93</summary>
      
    
    
    
    <category term="技术" scheme="https://champion-yang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redis" scheme="https://champion-yang.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>DRF源码解析</title>
    <link href="https://champion-yang.github.io/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://champion-yang.github.io/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2024-07-01T01:35:59.000Z</published>
    <updated>2024-07-04T08:41:04.918Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=3 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#drf%E7%BB%84%E4%BB%B6">DRF组件</a></li><li><a href="#1-web%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F">1. Web应用模式</a></li><li><a href="#2-api%E6%8E%A5%E5%8F%A3">2. api接口</a></li><li><a href="#3-restful-api%E8%A7%84%E8%8C%83">3. RESTful API规范</a><ul><li><a href="#%E5%B9%82%E7%AD%89%E6%80%A7">幂等性</a></li></ul></li><li><a href="#4-django%E7%9A%84cbv">4. Django的CBV</a><ul><li><a href="#41-cbv%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">4.1 CBV的简单使用</a></li><li><a href="#42-cbv%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">4.2 CBV的源码解析</a><ul><li><a href="#421-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE">4.2.1 面向对象知识点回顾</a><ul><li><a href="#1%E7%BB%A7%E6%89%BF">(1)继承</a></li><li><a href="#2%E5%8F%8D%E5%B0%84">(2)反射</a></li></ul></li><li><a href="#422-cbv%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">4.2.2 CBV的源码解析</a></li></ul></li></ul></li><li><a href="#5-django_rest_framework">5. Django_Rest_Framework</a></li><li><a href="#6-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE">6. 环境安装与配置</a></li><li><a href="#7-drf%E7%9A%84apiview%E8%A7%86%E5%9B%BE">7. DRF的APIView视图</a><ul><li><a href="#71-apiview%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">7.1 APIView的简单使用</a></li><li><a href="#72-apiview%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">7.2 APIView的源码解析</a></li><li><a href="#71%E8%AF%B7%E6%B1%82">7.1、请求</a><ul><li><a href="#711%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">7.1.1、常用属性</a><ul><li><a href="#1data">1).data</a></li><li><a href="#2query_params">2).query_params</a></li><li><a href="#3request_request">3)request._request</a></li></ul></li><li><a href="#712%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">7.1.2、基本使用</a></li></ul></li><li><a href="#72%E5%93%8D%E5%BA%94">7.2、响应</a><ul><li><a href="#721-%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F">7.2.1 构造方式</a></li><li><a href="#722-response%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">7.2.2 response对象的属性</a></li><li><a href="#723-%E7%8A%B6%E6%80%81%E7%A0%81">7.2.3 状态码</a></li></ul></li></ul></li><li><a href="#8-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8-serializer">8. 序列化器-Serializer</a><ul><li><a href="#81-%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8">8.1 定义序列化器</a></li><li><a href="#82-%E5%88%9B%E5%BB%BAserializer%E5%AF%B9%E8%B1%A1">8.2 创建Serializer对象</a></li><li><a href="#83-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8">8.3 序列化器的使用</a><ul><li><a href="#831-%E5%BA%8F%E5%88%97%E5%8C%96">8.3.1 序列化</a><ul><li><a href="#1%E5%9F%BA%E6%9C%AC%E5%BA%8F%E5%88%97%E5%8C%96">(1)基本序列化</a></li></ul></li><li><a href="#832--%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">8.3.2  反序列化</a><ul><li><a href="#1%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81">(1)数据验证</a><ul><li><a href="#1-validate_%E5%AD%97%E6%AE%B5%E5%90%8D">(1) validate_字段名</a></li><li><a href="#2-validate">(2) validate</a></li></ul></li><li><a href="#2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE">(2)反序列化-保存数据</a></li><li><a href="#3-%E9%99%84%E5%8A%A0%E8%AF%B4%E6%98%8E">(3) 附加说明</a></li></ul></li><li><a href="#833%E5%9F%BA%E4%BA%8Eapiview%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0">8.3.3、基于APIView的接口实现</a></li></ul></li><li><a href="#84-%E6%A8%A1%E5%9E%8B%E7%B1%BB%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8">8.4 模型类序列化器</a><ul><li><a href="#1%E5%AE%9A%E4%B9%89">(1)定义</a></li><li><a href="#2%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5">(2)指定字段</a></li><li><a href="#3%E6%B7%BB%E5%8A%A0%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0">(3)添加额外参数</a></li></ul></li></ul></li><li><a href="#9-%E8%A7%86%E5%9B%BE">9. 视图</a><ul><li><a href="#91genericapiview%E9%80%9A%E7%94%A8%E8%A7%86%E5%9B%BE%E7%B1%BB">9.1、GenericAPIView[通用视图类]</a><ul><li><a href="#1get_serializer_classself">(1)get_serializer_class(self)</a></li><li><a href="#2get_serializerself-args-kwargs">(2)get_serializer(self, *args, **kwargs)</a></li><li><a href="#3get_querysetself">(3)get_queryset(self)</a></li><li><a href="#4get_objectself">(4)get_object(self)</a></li></ul></li><li><a href="#925%E4%B8%AA%E8%A7%86%E5%9B%BE%E6%89%A9%E5%B1%95%E7%B1%BB">9.2、5个视图扩展类</a><ul><li><a href="#1listmodelmixin">(1)ListModelMixin</a></li><li><a href="#2createmodelmixin">（2）CreateModelMixin</a></li><li><a href="#3retrievemodelmixin">（3）RetrieveModelMixin</a></li><li><a href="#4updatemodelmixin">（4）UpdateModelMixin</a></li><li><a href="#5destroymodelmixin">（5）DestroyModelMixin</a></li></ul></li><li><a href="#93-genericapiview%E7%9A%84%E8%A7%86%E5%9B%BE%E5%AD%90%E7%B1%BB">9.3、 GenericAPIView的视图子类</a><ul><li><a href="#1createapiview">（1）CreateAPIView</a></li><li><a href="#2listapiview">（2）ListAPIView</a></li><li><a href="#3retrieveapiview">（3）RetrieveAPIView</a></li><li><a href="#4destoryapiview">（4）DestoryAPIView</a></li><li><a href="#5updateapiview">（5）UpdateAPIView</a></li><li><a href="#6listcreateapiview">（6）ListCreateAPIView</a></li><li><a href="#7retrieveupdateapiview">（7）RetrieveUpdateAPIView</a></li><li><a href="#8retrievedestoryapiview">（8）RetrieveDestoryAPIView</a></li><li><a href="#9retrieveupdatedestoryapiview">（9）RetrieveUpdateDestoryAPIView</a></li></ul></li><li><a href="#94%E8%A7%86%E5%9B%BE%E9%9B%86">9.4、视图集</a><ul><li><a href="#941viewset">9.4.1、ViewSet</a></li><li><a href="#942genericviewset">9.4.2、GenericViewSet</a></li><li><a href="#943modelviewset%E5%92%8Creadonlymodelviewset">9.4.3、ModelViewSet和ReadOnlyModelViewSet</a></li></ul></li></ul></li><li><a href="#10-%E8%B7%AF%E7%94%B1routers">10. 路由Routers</a><ul><li><a href="#101-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">10.1 使用方法</a></li><li><a href="#102-%E8%A7%86%E5%9B%BE%E9%9B%86%E4%B8%AD%E9%99%84%E5%8A%A0action%E7%9A%84%E5%A3%B0%E6%98%8E">10.2 视图集中附加action的声明</a></li><li><a href="#103-%E8%B7%AF%E7%94%B1router%E5%BD%A2%E6%88%90url%E7%9A%84%E6%96%B9%E5%BC%8F">10.3 路由router形成URL的方式</a></li></ul></li><li><a href="#11%E5%85%B6%E5%AE%83%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6">11、其它功能组件</a><ul><li><a href="#111-%E8%AE%A4%E8%AF%81authentication">11.1. 认证Authentication</a></li><li><a href="#112-%E6%9D%83%E9%99%90permissions">11.2. 权限Permissions</a><ul><li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li><li><a href="#%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9D%83%E9%99%90">提供的权限</a></li><li><a href="#%E4%B8%BE%E4%BE%8B">举例</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%83%E9%99%90">自定义权限</a></li></ul></li><li><a href="#113-%E9%99%90%E6%B5%81throttling">11.3. 限流Throttling</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a></li><li><a href="#%E5%8F%AF%E9%80%89%E9%99%90%E6%B5%81%E7%B1%BB">可选限流类</a></li></ul></li><li><a href="#114-%E8%BF%87%E6%BB%A4filtering">11.4. 过滤Filtering</a></li><li><a href="#115-%E6%8E%92%E5%BA%8Fordering">11.5. 排序Ordering</a></li><li><a href="#116-%E5%88%86%E9%A1%B5pagination">11.6. 分页Pagination</a></li><li><a href="#117-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-exceptions">11.7. 异常处理 Exceptions</a><ul><li><a href="#rest-framework%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%82%E5%B8%B8">REST framework定义的异常</a></li></ul></li><li><a href="#118-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3">11.8. 自动生成接口文档</a><ul><li><a href="#1181-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96">11.8.1. 安装依赖</a></li><li><a href="#1182-%E8%AE%BE%E7%BD%AE%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84">11.8.2. 设置接口文档访问路径</a></li><li><a href="#1183-%E6%96%87%E6%A1%A3%E6%8F%8F%E8%BF%B0%E8%AF%B4%E6%98%8E%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE">11.8.3. 文档描述说明的定义位置</a></li><li><a href="#1184-%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%BD%91%E9%A1%B5">11.8.4. 访问接口文档网页</a></li></ul></li></ul></li></ul><!-- /code_chunk_output --><h1 id="DRF组件"><a href="#DRF组件" class="headerlink" title="DRF组件"></a>DRF组件</h1><h1 id="1-Web应用模式"><a href="#1-Web应用模式" class="headerlink" title="1. Web应用模式"></a>1. Web应用模式</h1><p>在开发Web应用中, 有两种应用模式:</p><ol><li>前后端不分离[客户端看到的内容和所有界面效果都是由服务端提供出来的]。</li></ol><img src="/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/indepent_frontend_backend.png" class="" title="前后端不分离"><ol start="2"><li><p>前后端分离【把前端的界面效果(html，css，js分离到另一个服务端，python服务端只需要返回数据即可)】</p><p>前端形成一个独立的网站, 服务端构成一个独立的网站</p></li></ol><img src="/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/indepent_frontend_backend-16318493319127.png" class="" title="前后端分离"><h1 id="2-api接口"><a href="#2-api接口" class="headerlink" title="2. api接口"></a>2. api接口</h1><p>应用程序编程接口(Application Programming Interface, API接口), 就是应用程序对外提供了一个操作数据的入口, 这个入口可以是一个函数或类方法, 也可以是一个url地址或者一个网络地址. 当客户端调用这个入口, 应用程序则会执行对应代码操作, 给客户端完成相对应的功能.</p><p>当然, api接口在工作中是比较常见的开发内容, 有时候, 我们会调用其他人编写的api接口, 有时候, 我们也需要提供api接口给其他人操作. 由此就会带来一个问题, api接口往往都是一个函数、类方法、或者url或其他网络地址, 不断是哪一种, 当api接口编写过程中, 我们都要考虑一个问题就是这个接口应该怎么编写? 接口怎么写的更加容易维护和清晰, 这就需要大家在调用或者编写api接口的时候要有一个明确的编写规范!!!</p><p>为了在团队内部形成共识、防止个人习惯差异引起的混乱, 我们都需要找到一种大家都觉得很好的接口实现规范, 而且这种规范能够让后端写的接口, 用途一目了然, 减少客户端和服务端双方之间的合作成本.</p><p>目前市面上大部分公司开发人员使用的接口实现规范主要有:restful、RPC.</p><p>restful: 翻译成中文: <strong>资源状态转换</strong>.(表征性状态转移)</p><ul><li><p>把服务端提供的所有的数据&#x2F;文件都看成资源, 那么通过api接口请求数据的操作, 本质上来说就是对资源的操作了.</p><p>因此, restful中要求, 我们把当前接口对外提供哪种资源进行操作, 就把<strong>资源的名称写在url地址</strong>.</p></li><li><p>web开发中操作资源, 最常见的最通用的无非就是增删查改, 所以restful要求在地址栏中声明要操作的资源是什么. 然后通过<strong>http请求动词</strong>来说明对该资源进行哪一种操作</p><blockquote><p>POST <a href="http://www.xxx.com/api/students/">http://www.xxx.com/api/students/</a>   添加学生数据</p><p>GET    <a href="http://www.xxx.com/api/students/">http://www.xxx.com/api/students/</a>   获取所有学生</p><p>GET    <a href="http://www.xxx.com/api/students/">http://www.xxx.com/api/students/</a><pk>&#x2F;     获取id&#x3D;pk的学生</p><p>DELETE <a href="http://www.xxx.com/api/students/">http://www.xxx.com/api/students/</a><pk>&#x2F;   删除id&#x3D;pk的一个学生</p><p>PUT   <a href="http://www.xxx.com/api/students/">http://www.xxx.com/api/students/</a><pk>&#x2F;       修改一个学生的全部信息 [id, name, sex, age, ]</p><p>PATCH  <a href="http://www.xxx.com/api/students/">http://www.xxx.com/api/students/</a><pk>&#x2F;    修改一个学生的部分信息[age]</p></blockquote></li></ul><p>也就是说, 我们仅需要通过url地址上的资源名称结合HTTP请求动作, 就可以说明当前api接口的功能是什么了.restful是以资源为主的api接口规范, 体现在地址上就是资源就是以名词表达.</p><h1 id="3-RESTful-API规范"><a href="#3-RESTful-API规范" class="headerlink" title="3. RESTful API规范"></a>3. RESTful API规范</h1><img src="/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/restful.gif" class="" title="restful"><p>REST全称是Representational State Transfer, 中文意思是表述(编者注: 通常译为表征)性状态转移. 它首次出现在2000年Roy Fielding的博士论文中.</p><p>RESTful是一种专门为Web 开发而定义API接口的设计风格, 尤其适用于前后端分离的应用模式中.</p><p>这种风格的理念认为后端开发任务就是提供数据的, 对外提供的是数据资源的访问接口, 所以在定义接口时, 客户端访问的URL路径就表示这种要操作的数据资源.</p><p>而对于数据资源分别使用POST、DELETE、GET、UPDATE等请求动作来表达对数据的增删查改.</p><table><thead><tr><th>GET</th><th>&#x2F;students</th><th>获取所有学生</th></tr></thead><tbody><tr><td>请求方法</td><td>请求地址</td><td>后端操作</td></tr><tr><td>POST</td><td>&#x2F;students</td><td>增加学生</td></tr><tr><td>GET</td><td>&#x2F;students&#x2F;<pk></td><td>获取编号为pk的学生</td></tr><tr><td>PUT</td><td>&#x2F;students&#x2F;<pk></td><td>修改编号为pk的学生</td></tr><tr><td>DELETE</td><td>&#x2F;students&#x2F;<pk></td><td>删除编号为pk的学生</td></tr></tbody></table><p>restful规范是一种通用的规范, 不限制语言和开发框架的使用. 事实上, 我们可以使用任何一门语言, 任何一个框架都可以实现符合restful规范的API接口.</p><p>参考文档:<a href="http://www.runoob.com/w3cnote/restful-architecture.html">http://www.runoob.com/w3cnote/restful-architecture.html</a></p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>接口实现过程中, 会存在<strong>幂等性</strong>. 所谓幂等性是指代<strong>客户端发起多次同样请求时, 是否对于服务端里面的资源产生不同结果</strong>. 如果<strong>多次请求</strong>, 服务端<strong>结果</strong>还是<strong>一样</strong>, 则属于<strong>幂等接口</strong>, 如果多次请求, 服务端产生结果是不一样的, 则属于<strong>非幂等接口</strong>.</p><table><thead><tr><th>请求方式</th><th>是否幂等</th><th>是否安全</th></tr></thead><tbody><tr><td>GET</td><td>幂等</td><td>安全</td></tr><tr><td>POST</td><td>不幂等</td><td>不安全</td></tr><tr><td>PUT&#x2F;PATCH</td><td>幂等</td><td>不安全</td></tr><tr><td>DELETE</td><td>幂等</td><td>不安全</td></tr></tbody></table><h1 id="4-Django的CBV"><a href="#4-Django的CBV" class="headerlink" title="4. Django的CBV"></a>4. Django的CBV</h1><p>之前我们用的Django的视图函数叫FBV(也就是函数型视图函数), 这里我们来试试CBV(类视图函数)的写法. 类视图函数可以让代码看起来更简洁, 用起来更方便.</p><h2 id="4-1-CBV的简单使用"><a href="#4-1-CBV的简单使用" class="headerlink" title="4.1 CBV的简单使用"></a>4.1 CBV的简单使用</h2><p>视图类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;get请求book&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;post请求book&quot;</span>)</span><br></pre></td></tr></table></figure><p>路由:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;book/&#x27;</span>, views.BookView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="4-2-CBV的源码解析"><a href="#4-2-CBV的源码解析" class="headerlink" title="4.2 CBV的源码解析"></a>4.2 CBV的源码解析</h2><h3 id="4-2-1-面向对象知识点回顾"><a href="#4-2-1-面向对象知识点回顾" class="headerlink" title="4.2.1 面向对象知识点回顾"></a>4.2.1 面向对象知识点回顾</h3><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="(1)继承"></a>(1)继承</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sleep()  <span class="comment"># 一定要明确self是谁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sleeping...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wangwang</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;旺旺叫&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;仰天睡...&quot;</span>)</span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">&quot;alex&quot;</span>, <span class="number">23</span>)</span><br></pre></td></tr></table></figure><h4 id="2-反射"><a href="#2-反射" class="headerlink" title="(2)反射"></a>(2)反射</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, init_func_str</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">        func = <span class="built_in">getattr</span>(self, init_func_str)</span><br><span class="line">        func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sleeping...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wangwang</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;旺旺叫&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;仰天睡...&quot;</span>)</span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">&quot;alex&quot;</span>, <span class="number">23</span>, <span class="string">&quot;sleep&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-2-2-CBV的源码解析"><a href="#4-2-2-CBV的源码解析" class="headerlink" title="4.2.2 CBV的源码解析"></a>4.2.2 CBV的源码解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">class BookView(View):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def get(self, request):</span></span><br><span class="line"><span class="string">        return HttpResponse(&quot;get请求book&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def post(self, request):</span></span><br><span class="line"><span class="string">        return HttpResponse(&quot;post请求book&quot;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">class View:</span></span><br><span class="line"><span class="string">        @classonlymethod</span></span><br><span class="line"><span class="string">        def as_view(cls):</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">            def view(request):</span></span><br><span class="line"><span class="string">                self = cls()</span></span><br><span class="line"><span class="string">                return self.dispatch(request, *args, **kwargs)</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">            return view</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">      def dispatch(self, request):</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">            handler = getattr(self, request.method.lower()) # 按请求方式分发       </span></span><br><span class="line"><span class="string">            return handler(request, *args, **kwargs)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 路由</span></span><br><span class="line"><span class="string">path(&#x27;book/&#x27;, views.BookView.as_view()),</span></span><br><span class="line"><span class="string">path(&#x27;book/&#x27;, View.view),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 一旦用户发起请求，比如get请求访问/book/，得到的是get方法的响应结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">get请求访问/book/  =&gt;  view()  =&gt;   dispatch()  =&gt;  get()  </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="5-Django-Rest-Framework"><a href="#5-Django-Rest-Framework" class="headerlink" title="5. Django_Rest_Framework"></a>5. Django_Rest_Framework</h1><p>核心思想: 大量缩减编写api接口的代码</p><p>Django REST framework是一个建立在Django基础之上的Web 应用开发框架, 可以快速的开发REST API接口应用. 在REST framework中, 提供了序列化器Serialzier的定义, 可以帮助我们简化序列化与反序列化的过程, 不仅如此, 还提供丰富的类视图、扩展类、视图集来简化视图的编写工作. REST framework还提供了认证、权限、限流、过滤、分页、接口文档等功能支持. REST framework提供了一个API 的Web可视化界面来方便查看测试接口.</p><img src="/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/drf_logo-16318493501509.png" class="" title="drf_logo"><p>中文文档:<a href="https://q1mi.github.io/Django-REST-framework-documentation/#django-rest-framework">https://q1mi.github.io/Django-REST-framework-documentation/#django-rest-framework</a></p><p>github: <a href="https://github.com/encode/django-rest-framework/tree/master">https://github.com/encode/django-rest-framework/tree/master</a></p><p>特点:</p><blockquote><ul><li>提供了定义序列化器Serializer的方法, 可以快速根据 Django ORM 或者其它库自动序列化&#x2F;反序列化; </li><li>提供了丰富的类视图、Mixin扩展类, 简化视图的编写; </li><li>丰富的定制层级: 函数视图、类视图、视图集合到自动生成 API, 满足各种需要; </li><li>多种身份认证和权限认证方式的支持; [jwt]</li><li>内置了限流系统; </li><li>直观的 API web 界面; 【方便我们调试开发api接口】</li><li>可扩展性, 插件丰富</li></ul></blockquote><h1 id="6-环境安装与配置"><a href="#6-环境安装与配置" class="headerlink" title="6. 环境安装与配置"></a>6. 环境安装与配置</h1><p>DRF需要以下依赖:</p><ul><li>Python (3.5 以上)</li><li>Django (2.2 以上)</li></ul><p><strong>DRF是以Django子应用的方式提供的, 所以我们可以直接利用已有的Django环境而无需从新创建.(若没有Django环境, 需要先创建环境安装Django)</strong></p><p>前提是已经安装了django, 建议安装在虚拟环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># conda create -n drfdemo python=3.8</span></span><br><span class="line"><span class="comment"># pip install django==3.2.4  -i https://pypi.douban.com/simple</span></span><br><span class="line"></span><br><span class="line">pip install djangorestframework -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><h1 id="7-DRF的APIView视图"><a href="#7-DRF的APIView视图" class="headerlink" title="7. DRF的APIView视图"></a>7. DRF的APIView视图</h1><h2 id="7-1-APIView的简单使用"><a href="#7-1-APIView的简单使用" class="headerlink" title="7.1 APIView的简单使用"></a>7.1 APIView的简单使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.views.APIView</span><br></pre></td></tr></table></figure><p><code>APIView</code> 是REST framework提供的所有视图的基类, 继承自Django的 <code>View</code> 父类.</p><p>相较于CBV, 路由不变, 视图不变, 继承类改为 <code>APIView</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;APIView:get请求book&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;APIView:post请求book&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="7-2-APIView的源码解析"><a href="#7-2-APIView的源码解析" class="headerlink" title="7.2 APIView的源码解析"></a>7.2 APIView的源码解析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;APIView:get请求book&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;APIView:post请求book&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APIView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">as_view</span>(<span class="params">cls</span>):</span><br><span class="line">        view = <span class="built_in">super</span>().as_view()</span><br><span class="line">        view.cls = cls</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="comment"># （1）构建新的request对象</span></span><br><span class="line">        request = self.initialize_request(request, *args, **kwargs)</span><br><span class="line">        self.request = request</span><br><span class="line">        <span class="comment"># （2）认证、权限、限流组件三件套</span></span><br><span class="line">        self.initial(request, *args, **kwargs)</span><br><span class="line">        <span class="comment"># （3）分发</span></span><br><span class="line">        handler = <span class="built_in">getattr</span>(self, request.method.lower()) <span class="comment"># 按请求方式分发       </span></span><br><span class="line">        <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line"><span class="meta">    @classonlymethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">as_view</span>(<span class="params">cls</span>):</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">request</span>):</span><br><span class="line">            self = cls()</span><br><span class="line">            <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">self, request</span>):</span><br><span class="line">        </span><br><span class="line">        handler = <span class="built_in">getattr</span>(self, request.method.lower()) <span class="comment"># 按请求方式分发       </span></span><br><span class="line">        <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="comment"># 路由</span></span><br><span class="line">path(<span class="string">&#x27;book/&#x27;</span>, views.BookView.as_view()),</span><br><span class="line">path(<span class="string">&#x27;book/&#x27;</span>, View.view),</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一旦用户发起请求，比如get请求访问/book/,依然得到get方法的响应</span></span><br><span class="line">get请求访问/book/ =&gt; View.view()  =&gt;   APIView.dispatch()  =&gt;  BookView.get()  </span><br></pre></td></tr></table></figure><p><code>APIView</code> 与 <code>View</code> 的不同之处在于:</p><blockquote><ul><li>传入到视图方法中的是REST framework的 <code>Request</code> 对象, 而不是Django的 <code>HttpRequeset</code> 对象; </li><li>视图方法可以返回REST framework的 <code>Response</code> 对象, 视图会为响应数据设置(render)符合前端期望要求的格式; </li><li>任何 <code>APIException</code> 异常都会被捕获到, 并且处理成合适格式的响应信息返回给客户端; </li><li>重新声明了一个新的as_views方法并在dispatch()进行路由分发前, 会对请求的客户端进行身份认证、权限检查、流量控制.</li></ul></blockquote><p>DRF在django原有的基础上, 新增了一个request对象继承到了APIVIew视图类, 并在django原有的HttpResponse响应类的基础上实现了一个子类rest_framework.response. Response响应类. 这两个类, 都是基于内容协商来完成数据的格式转换的.</p><blockquote><p>request-&gt;parser-&gt;识别客户端请求头中的Content-Type来完成数据转换成-&gt;类字典(QueryDict, 字典的子类)</p><p>response-&gt;renderer-&gt;识别客户端请求头的”Accept”来提取客户单期望的返回数据格式, -&gt; 转换成客户端的期望格式数据</p></blockquote><h2 id="7-1、请求"><a href="#7-1、请求" class="headerlink" title="7.1、请求"></a>7.1、请求</h2><p>REST framework 传入视图的request对象不再是Django默认的HttpRequest对象, 而是REST framework提供的扩展了HttpRequest类的<strong>Request</strong>类的对象.</p><p>REST framework 提供了<strong>Parser</strong>解析器, 在接收到请求后会自动根据Content-Type指明的请求数据类型(如JSON、表单等)将请求数据进行parse解析, 解析为类字典[QueryDict]对象保存到<strong>Request</strong>对象中.</p><p><strong>Request对象的数据是自动根据前端发送数据的格式进行解析之后的结果.</strong></p><p>无论前端发送的哪种格式的数据, 我们都可以以统一的方式读取数据.</p><h3 id="7-1-1、常用属性"><a href="#7-1-1、常用属性" class="headerlink" title="7.1.1、常用属性"></a>7.1.1、常用属性</h3><h4 id="1-data"><a href="#1-data" class="headerlink" title="1).data"></a>1).data</h4><p><code>request.data</code> 返回解析之后的请求体数据. 类似于Django中标准的 <code>request.POST</code> 和 <code>request.FILES</code> 属性, 但提供如下特性:</p><ul><li>包含了解析之后的文件和非文件数据</li><li>包含了对POST、PUT、PATCH请求方式解析后的数据</li><li>利用了REST framework的parsers解析器, 不仅支持表单类型数据, 也支持JSON数据</li></ul><h4 id="2-query-params"><a href="#2-query-params" class="headerlink" title="2).query_params"></a>2).query_params</h4><p><code>request.query_params</code> 与Django标准的 <code>request.GET</code> 相同, 只是更换了更正确的名称而已.</p><h4 id="3-request-request"><a href="#3-request-request" class="headerlink" title="3)request._request"></a>3)request._request</h4><p>获取django封装的Request对象</p><h3 id="7-1-2、基本使用"><a href="#7-1-2、基本使用" class="headerlink" title="7.1.2、基本使用"></a>7.1.2、基本使用</h3><p>视图代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.http.response <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.http.request <span class="keyword">import</span> HttpRequest</span><br><span class="line"><span class="keyword">from</span> django.core.handlers.wsgi <span class="keyword">import</span> WSGIRequest</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReqView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,request</span>):</span><br><span class="line">        <span class="built_in">print</span>(request)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">默认情况下, 编写视图类时，如果继承的是django内置的django.view.View视图基类，</span></span><br><span class="line"><span class="string">则视图方法中得到的request对象，是django默认提供的django.core.handlers.wsgi.WSGIRequest</span></span><br><span class="line"><span class="string">WSGIRequest这个请求处理对象，无法直接提供的关于json数据数据处理。</span></span><br><span class="line"><span class="string">在编写api接口时很不方便，所以drf为了简写这块内容，在原来的HttpRequest的基础上面，新增了一个Request对象</span></span><br><span class="line"><span class="string">这个Request对象是单独声明的和原来django的HttpRequest不是父子关系。</span></span><br><span class="line"><span class="string">同时注意：</span></span><br><span class="line"><span class="string">   要使用drf提供的Request请求处理对象，必须在编写视图类时继承drf提供的视图基类</span></span><br><span class="line"><span class="string">   from rest_framework.views import APIView</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">   如果使用drf提供的视图基类APIView编写类视图，则必须使用来自drf提供的Request请求对象和Response响应对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReqAPIView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,request</span>):</span><br><span class="line">        <span class="comment"># rest_framework.request.Request对象</span></span><br><span class="line">        <span class="built_in">print</span>(request) <span class="comment"># &lt;rest_framework.request.Request: GET &#x27;/req/req2?name=xiaoming&amp;age=17&amp;lve=swim&amp;lve=code&#x27;&gt;</span></span><br><span class="line">        <span class="comment"># 获取查询字符串</span></span><br><span class="line">        <span class="built_in">print</span>(request.query_params)</span><br><span class="line">        <span class="comment"># 没有参数情况下： &lt;QueryDict: &#123;&#125;&gt;</span></span><br><span class="line">        <span class="comment"># 有参数的情况下： &lt;QueryDict: &#123;&#x27;name&#x27;: [&#x27;xiaoming&#x27;], &#x27;age&#x27;: [&#x27;17&#x27;], &#x27;lve&#x27;: [&#x27;swim&#x27;, &#x27;code&#x27;]&#125;&gt;</span></span><br><span class="line">        <span class="comment"># 所以，request.query_params的返回值操作和原来在django里面是一模一样的</span></span><br><span class="line">        <span class="built_in">print</span>(request.query_params.get(<span class="string">&quot;name&quot;</span>)) <span class="comment"># xiaoming</span></span><br><span class="line">        <span class="built_in">print</span>(request.query_params.getlist(<span class="string">&quot;lve&quot;</span>)) <span class="comment"># [&#x27;swim&#x27;, &#x27;code&#x27;]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="comment"># 获取请求体</span></span><br><span class="line">        <span class="built_in">print</span>(request.data) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;xiaoming&#x27;, &#x27;age&#x27;: 16, &#x27;lve&#x27;: [&#x27;swim&#x27;, &#x27;code&#x27;]&#125;</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;直接从请求体中提取数据转</span></span><br><span class="line"><span class="string">        # 客户端如果上传了json数据，直接返回字典</span></span><br><span class="line"><span class="string">        &#123;&#x27;name&#x27;: &#x27;灰太狼&#x27;, &#x27;age&#x27;: 20, &#x27;sex&#x27;: 1, &#x27;classmate&#x27;: &#x27;301&#x27;, &#x27;description&#x27;: &#x27;我还会再回来的~&#x27;&#125;</span></span><br><span class="line"><span class="string">        # 客户端如果上传了表单数据，直接返回QueryDict</span></span><br><span class="line"><span class="string">        &lt;QueryDict: &#123;&#x27;name&#x27;: [&#x27;xiaohui&#x27;], &#x27;age&#x27;: [&#x27;18&#x27;]&#125;&gt;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(request.FILES) <span class="comment"># 获取上传文件列表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 要获取django原生提供的HttpRequest对象，可以通过request._request来获取到</span></span><br><span class="line">        <span class="built_in">print</span>(request._request.META.get(<span class="string">&quot;Accept&quot;</span>)) <span class="comment"># 当值为None时，drf默认在响应数据时按json格式返回</span></span><br><span class="line">        <span class="comment"># response = Response(data=&quot;not ok&quot;, status=204, headers=&#123;&quot;Company&quot;:&quot;Oldboy&quot;&#125;)</span></span><br><span class="line">        response = Response(data=<span class="string">&quot;not ok&quot;</span>, status=status.HTTP_400_BAD_REQUEST, headers=&#123;<span class="string">&quot;Company&quot;</span>:<span class="string">&quot;Oldboy&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h2 id="7-2、响应"><a href="#7-2、响应" class="headerlink" title="7.2、响应"></a>7.2、响应</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.response.Response</span><br></pre></td></tr></table></figure><p>REST framework提供了一个响应类 <code>Response</code> , 使用该类构造响应对象时, 响应的具体数据内容会被转换(render渲染器)成符合前端需求的类型.</p><p>REST framework提供了 <code>Renderer</code> 渲染器, 用来根据请求头中的 <code>Accept</code> (接收数据类型声明)来自动转换响应数据到对应格式. 如果前端请求中未进行Accept声明, 则会采用Content-Type方式处理响应数据, 我们可以通过配置来修改默认响应格式.</p><p>可以在<strong>rest_framework.settings</strong>查找所有的drf默认配置项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_RENDERER_CLASSES&#x27;</span>: (  <span class="comment"># 默认响应渲染类</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.JSONRenderer&#x27;</span>,  <span class="comment"># json渲染器，返回json数据</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;</span>,  <span class="comment"># 浏览器API渲染器，返回调试界面</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-1-构造方式"><a href="#7-2-1-构造方式" class="headerlink" title="7.2.1 构造方式"></a>7.2.1 构造方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response(data, status=<span class="literal">None</span>, template_name=<span class="literal">None</span>, headers=<span class="literal">None</span>, content_type=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>drf的响应处理类和请求处理类不一样, Response就是django的HttpResponse响应处理类的子类.</p><p><code>data</code> 数据不要是render处理之后的数据, 只需传递python的内建类型数据即可, REST framework会使用 <code>renderer</code> 渲染器处理 <code>data</code> .</p><p><code>data</code> 不能是复杂结构的数据, 如Django的模型类对象, 对于这样的数据我们可以使用 <code>Serializer</code> 序列化器序列化处理后(转为了Python字典类型)再传递给 <code>data</code> 参数.</p><p>参数说明:</p><blockquote><ul><li><code>data</code> : 为响应准备的序列化处理后的数据; </li><li><code>status</code> : 状态码, 默认200; </li><li><code>template_name</code> : 模板名称, 如果使用 <code>HTMLRenderer</code> 时需指明; </li><li><code>headers</code> : 用于存放响应头信息的字典; </li><li><code>content_type</code> : 响应数据的Content-Type, 通常此参数无需传递, REST framework会根据前端所需类型数据来设置该参数</li></ul></blockquote><h4 id="7-2-2-response对象的属性"><a href="#7-2-2-response对象的属性" class="headerlink" title="7.2.2 response对象的属性"></a>7.2.2 response对象的属性</h4><blockquote><p>.data: 传给response对象的序列化后, 但尚未render处理的数据</p><p>.status_code: 状态码的数字</p><p>.content: 经过render处理后的响应数据</p></blockquote><h4 id="7-2-3-状态码"><a href="#7-2-3-状态码" class="headerlink" title="7.2.3 状态码"></a>7.2.3 状态码</h4><p>为了方便设置状态码, REST framewrok在 <code>rest_framework.status</code> 模块中提供了常用http状态码的常量.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27; 1）信息告知 - 1xx &#x27;&#x27;&#x27;</span><br><span class="line">HTTP_100_CONTINUE</span><br><span class="line">HTTP_101_SWITCHING_PROTOCOLS</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27; 2）成功 - 2xx&#x27;&#x27;&#x27;</span><br><span class="line">HTTP_200_OK</span><br><span class="line">HTTP_201_CREATED</span><br><span class="line">HTTP_202_ACCEPTED</span><br><span class="line">HTTP_203_NON_AUTHORITATIVE_INFORMATION</span><br><span class="line">HTTP_204_NO_CONTENT</span><br><span class="line">HTTP_205_RESET_CONTENT</span><br><span class="line">HTTP_206_PARTIAL_CONTENT</span><br><span class="line">HTTP_207_MULTI_STATUS</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27; 3）重定向 - 3xx&#x27;&#x27;&#x27;</span><br><span class="line">HTTP_300_MULTIPLE_CHOICES</span><br><span class="line">HTTP_301_MOVED_PERMANENTLY</span><br><span class="line">HTTP_302_FOUND</span><br><span class="line">HTTP_303_SEE_OTHER</span><br><span class="line">HTTP_304_NOT_MODIFIED</span><br><span class="line">HTTP_305_USE_PROXY</span><br><span class="line">HTTP_306_RESERVED</span><br><span class="line">HTTP_307_TEMPORARY_REDIRECT</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27; 4）客户端错误 - 4xx&#x27;&#x27;&#x27;</span><br><span class="line">HTTP_400_BAD_REQUEST</span><br><span class="line">HTTP_401_UNAUTHORIZED</span><br><span class="line">HTTP_402_PAYMENT_REQUIRED</span><br><span class="line">HTTP_403_FORBIDDEN</span><br><span class="line">HTTP_404_NOT_FOUND</span><br><span class="line">HTTP_405_METHOD_NOT_ALLOWED</span><br><span class="line">HTTP_406_NOT_ACCEPTABLE</span><br><span class="line">HTTP_407_PROXY_AUTHENTICATION_REQUIRED</span><br><span class="line">HTTP_408_REQUEST_TIMEOUT</span><br><span class="line">HTTP_409_CONFLICT</span><br><span class="line">HTTP_410_GONE</span><br><span class="line">HTTP_411_LENGTH_REQUIRED</span><br><span class="line">HTTP_412_PRECONDITION_FAILED</span><br><span class="line">HTTP_413_REQUEST_ENTITY_TOO_LARGE</span><br><span class="line">HTTP_414_REQUEST_URI_TOO_LONG</span><br><span class="line">HTTP_415_UNSUPPORTED_MEDIA_TYPE</span><br><span class="line">HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE</span><br><span class="line">HTTP_417_EXPECTATION_FAILED</span><br><span class="line">HTTP_422_UNPROCESSABLE_ENTITY</span><br><span class="line">HTTP_423_LOCKED</span><br><span class="line">HTTP_424_FAILED_DEPENDENCY</span><br><span class="line">HTTP_428_PRECONDITION_REQUIRED</span><br><span class="line">HTTP_429_TOO_MANY_REQUESTS</span><br><span class="line">HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE</span><br><span class="line">HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27; 5）服务器错误 - 5xx&#x27;&#x27;&#x27;</span><br><span class="line">HTTP_500_INTERNAL_SERVER_ERROR</span><br><span class="line">HTTP_501_NOT_IMPLEMENTED</span><br><span class="line">HTTP_502_BAD_GATEWAY</span><br><span class="line">HTTP_503_SERVICE_UNAVAILABLE</span><br><span class="line">HTTP_504_GATEWAY_TIMEOUT</span><br><span class="line">HTTP_505_HTTP_VERSION_NOT_SUPPORTED</span><br><span class="line">HTTP_507_INSUFFICIENT_STORAGE</span><br><span class="line">HTTP_511_NETWORK_AUTHENTICATION_REQUIRED</span><br></pre></td></tr></table></figure><h1 id="8-序列化器-Serializer"><a href="#8-序列化器-Serializer" class="headerlink" title="8. 序列化器-Serializer"></a>8. 序列化器-Serializer</h1><p>作用:</p><pre><code>1. 序列化,序列化器会把模型对象转换成字典,经过response以后变成json字符串2. 反序列化,把客户端发送过来的数据,经过request以后变成字典,序列化器可以把字典转成模型3. 反序列化,完成数据校验功能</code></pre><h2 id="8-1-定义序列化器"><a href="#8-1-定义序列化器" class="headerlink" title="8.1 定义序列化器"></a>8.1 定义序列化器</h2><p>Django REST framework中的Serializer使用类来定义, 须继承自rest_framework.serializers. Serializer.</p><p>接下来, 为了方便演示序列化器的使用, 我们先创建一个新的子应用sers</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp sers</span><br></pre></td></tr></table></figure><p>我们创建几个图书相关模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; Create your models here.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(models.Model):</span><br><span class="line">    title = models.CharField(max_length=<span class="number">32</span>,verbose_name=<span class="string">&quot;书籍名称&quot;</span>)</span><br><span class="line">    price = models.IntegerField(verbose_name=<span class="string">&quot;价格&quot;</span>)</span><br><span class="line">    pub_date = models.DateField(verbose_name=<span class="string">&quot;出版日期&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们想为Book模型类提供一个序列化器, 可以定义如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.Serializer):</span><br><span class="line">    title = serializers.CharField()</span><br><span class="line">    price = serializers.IntegerField()</span><br><span class="line">    pub_date = serializers.DateField()</span><br></pre></td></tr></table></figure><p>**注意:serializer不是只能为数据库模型类定义, 也可以为非数据库模型类的数据定义.**serializer是独立于数据库之外的存在.</p><h2 id="8-2-创建Serializer对象"><a href="#8-2-创建Serializer对象" class="headerlink" title="8.2 创建Serializer对象"></a>8.2 创建Serializer对象</h2><p>定义好Serializer类后, 就可以创建Serializer对象了.</p><p>Serializer的构造方法为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializer(instance=<span class="literal">None</span>, data=empty, **kwarg)</span><br></pre></td></tr></table></figure><p>说明:</p><p>1)用于序列化时, 将模型类对象传入<strong>instance</strong>参数</p><p>2)用于反序列化时, 将要被反序列化的数据传入<strong>data</strong>参数</p><p>3)除了instance和data参数外, 在构造Serializer对象时, 还可通过<strong>context</strong>参数额外添加数据, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializer = AccountSerializer(account, context=&#123;<span class="string">&#x27;request&#x27;</span>: request&#125;)</span><br></pre></td></tr></table></figure><p><strong>通过context参数附加的数据, 可以通过Serializer对象的context属性获取.</strong></p><blockquote><ol><li>使用序列化器的时候一定要注意, 序列化器声明了以后, 不会自动执行, 需要我们在视图中进行调用才可以.</li><li>序列化器无法直接接收数据, 需要我们在视图中创建序列化器对象时把使用的数据传递过来.</li><li>序列化器的字段声明类似于我们前面使用过的表单系统.</li><li>开发restful api时, 序列化器会帮我们把模型数据转换成字典.</li><li>drf提供的视图会帮我们把字典转换成json, 或者把客户端发送过来的数据转换字典.</li></ol></blockquote><h2 id="8-3-序列化器的使用"><a href="#8-3-序列化器的使用" class="headerlink" title="8.3 序列化器的使用"></a>8.3 序列化器的使用</h2><p>序列化器的使用分两个阶段:</p><ol><li>处理客户端请求时，使用序列化器可以完成对数据的反序列化。</li><li>处理服务器响应时，使用序列化器可以完成对数据的序列化。</li></ol><h3 id="8-3-1-序列化"><a href="#8-3-1-序列化" class="headerlink" title="8.3.1 序列化"></a>8.3.1 序列化</h3><h4 id="1-基本序列化"><a href="#1-基本序列化" class="headerlink" title="(1)基本序列化"></a>(1)基本序列化</h4><p>《1》 先查询出一个学生对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sers.models <span class="keyword">import</span> Book</span><br><span class="line">book = Book.objects.get(pk=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>《2》 构造序列化器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> BookSerializer</span><br><span class="line">bookSer = BookSerializer(instance=book)</span><br></pre></td></tr></table></figure><p>《3》获取序列化数据</p><p>通过data属性可以获取序列化后的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bookSer.data </span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;乱世佳人&#x27;, &#x27;price&#x27;: 335, &#x27;pub_date&#x27;: &#x27;2012-12-12&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>路由视图代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"></span><br><span class="line">path(<span class="string">&quot;sers/&quot;</span>, include(<span class="string">&quot;sers.urls&quot;</span>)), </span><br><span class="line"></span><br><span class="line"><span class="comment"># sers.urls</span></span><br><span class="line"></span><br><span class="line">path(<span class="string">&#x27;books/(\d+)&#x27;</span>, BookView.as_view()), </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> .sers <span class="keyword">import</span> BookSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request,<span class="built_in">id</span></span>):</span><br><span class="line">        book = Book.objects.get(pk=<span class="built_in">id</span>)</span><br><span class="line">        bs = BookSerializer(instance=book)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br></pre></td></tr></table></figure><p>《5》如果要被序列化的是包含多条数据的查询集QuerySet, 可以通过添加<strong>many&#x3D;True</strong>参数补充说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="comment"># book = Book.objects.get(pk=1)</span></span><br><span class="line">        books = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">        bs = BookSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br></pre></td></tr></table></figure><h3 id="8-3-2-反序列化"><a href="#8-3-2-反序列化" class="headerlink" title="8.3.2  反序列化"></a>8.3.2  反序列化</h3><h4 id="1-数据验证"><a href="#1-数据验证" class="headerlink" title="(1)数据验证"></a>(1)数据验证</h4><p>使用序列化器进行反序列化时, 需要对数据进行验证后, 才能获取验证成功的数据或保存成模型类对象.</p><p>在获取反序列化的数据前, 必须调用**is_valid()**方法进行验证, 验证成功返回True, 否则返回False.</p><p>验证失败, 可以通过序列化器对象的<strong>errors</strong>属性获取错误信息, 返回字典, 包含了字段和字段的错误. 如果是非字段错误, 可以通过修改REST framework配置中的<strong>NON_FIELD_ERRORS_KEY</strong>来控制错误字典中的键名.</p><p>验证成功, 可以通过序列化器对象的<strong>validated_data</strong>属性获取数据.</p><p>在定义序列化器时, 指明每个字段的序列化类型和选项参数, 本身就是一种验证行为.</p><p>通过构造序列化器对象, 并将要反序列化的数据传递给data构造参数, 进而进行验证.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sers.sers <span class="keyword">import</span> BookSerializer</span><br><span class="line">bs = BookSerializer(data=&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;小王子&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">100</span>&#125;)</span><br><span class="line">bs.is_valid()  <span class="comment"># 必须先要is_valid,才会有bs.validated_data和bs.errors</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">bs.validated_data</span><br><span class="line">&#123;&#125;</span><br><span class="line">bs.errors</span><br><span class="line">&#123;<span class="string">&#x27;pub_date&#x27;</span>: [ErrorDetail(string=<span class="string">&#x27;This field is required.&#x27;</span>, code=<span class="string">&#x27;required&#x27;</span>)]&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以设置required&#x3D;False让校验字段可以为空!</p></blockquote><p>is_valid()方法还可以在验证失败时抛出异常serializers. ValidationError, 可以通过传递<strong>raise_exception&#x3D;True</strong>参数开启, REST framework接收到此异常, 会向前端返回HTTP 400 Bad Request响应.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Return a 400 response if the data was invalid.serializer.is_valid(raise_exception=True)</span></span><br></pre></td></tr></table></figure><p>如果觉得这些还不够, 需要再补充定义验证行为, 可以使用以下三种方法:</p><h5 id="1-validate-字段名"><a href="#1-validate-字段名" class="headerlink" title="(1) validate_字段名"></a>(1) validate_字段名</h5><p>对 <code>&lt;field_name&gt;</code> 字段进行验证, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.Serializer):</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = serializers.IntegerField(required=<span class="literal">True</span>)</span><br><span class="line">    pub_date = serializers.DateField(required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate_title</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;django&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图书不是关于Django的&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sers.sers <span class="keyword">import</span> BookSerializer</span><br><span class="line">bs = BookSerializer(data=&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;小王子&quot;</span>,<span class="string">&quot;price&quot;</span>:<span class="number">100</span>&#125;)</span><br><span class="line">bs.is_valid()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">bs.errors</span><br><span class="line">&#123;<span class="string">&#x27;title&#x27;</span>: [ErrorDetail(string=<span class="string">&#x27;图书不是关于Django的&#x27;</span>, code=<span class="string">&#x27;invalid&#x27;</span>)], <span class="string">&#x27;pub_date&#x27;</span>: [ErrorDetail(string=<span class="string">&#x27;This field is required.&#x27;</span>, code=<span class="string">&#x27;required&#x27;</span>)]&#125;</span><br></pre></td></tr></table></figure><p>还有一种写法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">title_django</span>(<span class="params">self, value</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;django&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图书不是关于Django的&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers. Serializer):</span><br><span class="line"></span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">32</span>,validators=[title_django,])</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-validate"><a href="#2-validate" class="headerlink" title="(2) validate"></a>(2) validate</h5><p>在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.Serializer):</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">    price = serializers.IntegerField(required=<span class="literal">False</span>)</span><br><span class="line">    pub_date = serializers.DateField(required=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    bread = serializers.IntegerField(label=<span class="string">&#x27;阅读量&#x27;</span>, max_value=<span class="number">2147483647</span>, min_value=-<span class="number">2147483648</span>, required=<span class="literal">False</span>)</span><br><span class="line">    bcomment = serializers.IntegerField(label=<span class="string">&#x27;评论量&#x27;</span>, max_value=<span class="number">2147483647</span>, min_value=-<span class="number">2147483648</span>, required=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate_title</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;django&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> value.lower():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&quot;图书不是关于Django的&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">self, data</span>):</span><br><span class="line">        bread = data.get(<span class="string">&quot;bread&quot;</span>)</span><br><span class="line">        bcomment = data.get(<span class="string">&quot;bcomment&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> bread &lt; bcomment:</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&#x27;阅读量小于评论量&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bs = BookSerializer(data=&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;Django深入浅出&quot;</span>,<span class="string">&quot;bread&quot;</span>:<span class="number">100</span>,<span class="string">&quot;bcomment&quot;</span>:<span class="number">200</span>,<span class="string">&quot;publish_id&quot;</span>:<span class="number">1</span>&#125;)</span><br><span class="line">bs.is_valid()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">bs.errors</span><br><span class="line">&#123;<span class="string">&#x27;non_field_errors&#x27;</span>: [ErrorDetail(string=<span class="string">&#x27;阅读量小于评论量&#x27;</span>, code=<span class="string">&#x27;invalid&#x27;</span>)]&#125;</span><br></pre></td></tr></table></figure><h4 id="2-反序列化-保存数据"><a href="#2-反序列化-保存数据" class="headerlink" title="(2)反序列化-保存数据"></a>(2)反序列化-保存数据</h4><p>前面的验证数据成功后, 我们可以使用序列化器来完成数据反序列化的过程. 这个过程可以把数据转成模型类对象.</p><p>可以通过实现create()和update()两个方法来实现.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.Serializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, validated_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;新建&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, instance, validated_data</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure><p>实现了上述两个方法后, 在反序列化数据的时候, 就可以通过save()方法返回一个数据对象实例了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book = serializer.save()</span><br></pre></td></tr></table></figure><blockquote><p>1、如果创建序列化器对象的时候, 没有传递instance实例, 则调用save()方法的时候, create()被调用</p><p>2、相反, 如果传递了instance实例, 则调用save()方法的时候, update()被调用.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path , include</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sers.views <span class="keyword">import</span> BookView, BookDetailView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;books/&#x27;</span>, BookView.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;books/(?P&lt;pk&gt;\d+)/&#x27;</span>, BookDetailView.as_view()),</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列化器</span></span><br><span class="line"><span class="comment"># 声明序列化器，所有的序列化器都要直接或者间接继承于 Serializer</span></span><br><span class="line"><span class="comment"># 其中，ModelSerializer是Serializer的子类，ModelSerializer在Serializer的基础上进行了代码简化</span></span><br></pre></td></tr></table></figure><h4 id="3-附加说明"><a href="#3-附加说明" class="headerlink" title="(3) 附加说明"></a>(3) 附加说明</h4><ol><li>在对序列化器进行save()保存时, 可以额外传递数据, 这些数据可以在create()和update()中的validated_data参数获取到</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># request.user 是django中记录当前登录用户的模型对象serializer.save(owner=request.user)</span></span><br></pre></td></tr></table></figure><p>2)默认序列化器必须传递所有required的字段, 否则会抛出验证异常. 但是我们可以使用partial参数来允许部分字段更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Update `comment` with partial dataserializer = CommentSerializer(comment, data=&#123;&#x27;content&#x27;: u&#x27;foo bar&#x27;&#125;, partial=True)</span></span><br></pre></td></tr></table></figure><h3 id="8-3-3、基于APIView的接口实现"><a href="#8-3-3、基于APIView的接口实现" class="headerlink" title="8.3.3、基于APIView的接口实现"></a>8.3.3、基于APIView的接口实现</h3><p>路由:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;book/&#x27;</span>, views.BookView.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;book/(\d+)&#x27;</span>, views.BookDetailView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>视图:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27; Create your views here.&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;设计增删改查查接口&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;序列化器&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Book</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.Serializer):</span><br><span class="line">    title = serializers.CharField()</span><br><span class="line">    price = serializers.IntegerField()</span><br><span class="line">    pub_date = serializers.DateField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, validated_data</span>):</span><br><span class="line">        new_book = Book.objects.create(**validated_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_book</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, instance, validated_data</span>):</span><br><span class="line">        Book.objects.<span class="built_in">filter</span>(pk=instance.pk).update(**validated_data)</span><br><span class="line">        instance = Book.objects.get(pk=instance.pk)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;视图&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        books = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">        bs = BookSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        bs = BookSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        book = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=book)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        instance = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=instance, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        Book.objects.get(pk=pk).delete()</span><br><span class="line">        <span class="keyword">return</span> Response()</span><br></pre></td></tr></table></figure><h2 id="8-4-模型类序列化器"><a href="#8-4-模型类序列化器" class="headerlink" title="8.4 模型类序列化器"></a>8.4 模型类序列化器</h2><p>如果我们想要使用序列化器对应的是Django的模型类, DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类.</p><p>ModelSerializer与常规的Serializer相同, 但提供了:</p><ul><li>基于模型类自动生成一系列字段</li><li>基于模型类自动为Serializer生成validators, 比如unique_together</li><li>包含默认的create()和update()的实现</li></ul><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h4><p>比如我们创建一个BookInfoSerializer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers. ModelSerializer):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>model 指明参照哪个模型类</li><li>fields 指明为模型类的哪些字段生成</li></ul><p>我们可以在python manage.py shell中查看自动生成的BookSerializer的具体实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;视图&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        books = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">        bs = BookSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        bs = BookSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        book = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=book)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        instance = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=instance, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        Book.objects.get(pk=pk).delete()</span><br><span class="line">        <span class="keyword">return</span> Response()</span><br></pre></td></tr></table></figure><blockquote><p>注意, 只有序列化器改为BookSerializer, 其他部分都没动</p></blockquote><h4 id="2-指定字段"><a href="#2-指定字段" class="headerlink" title="(2)指定字段"></a>(2)指定字段</h4><ol><li>使用<strong>fields</strong>来明确字段, <code>__all__</code> 表名包含所有字段, 也可以写明具体哪些字段, 如</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span></span><br><span class="line">        model = BookInfo</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;pub_date&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<strong>exclude</strong>可以明确排除掉哪些字段</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        exclude = (<span class="string">&#x27;pub_date&#x27;</span>,)</span><br></pre></td></tr></table></figure><ol start="3"><li>指明只读字段</li></ol><p>可以通过<strong>read_only_fields</strong>指明只读字段, 即仅用于序列化输出的字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;pub_date&#x27;</span>， <span class="string">&#x27;bread&#x27;</span>, <span class="string">&#x27;bcomment&#x27;</span>)</span><br><span class="line">        read_only_fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;bread&#x27;</span>, <span class="string">&#x27;bcomment&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="3-添加额外参数"><a href="#3-添加额外参数" class="headerlink" title="(3)添加额外参数"></a>(3)添加额外参数</h4><p>我们可以使用<strong>extra_kwargs</strong>参数为ModelSerializer添加或修改原有的选项参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;pub_date&#x27;</span>)</span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;bread&#x27;</span>: &#123;<span class="string">&#x27;min_value&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;required&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&#x27;bcomment&#x27;</span>: &#123;<span class="string">&#x27;min_value&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;required&#x27;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">BookSerializer():</span></span><br><span class="line"><span class="string">    id = IntegerField(label=&#x27;ID&#x27;, read_only=True)</span></span><br><span class="line"><span class="string">    title = CharField(label=&#x27;书籍名称&#x27;, max_length=32)</span></span><br><span class="line"><span class="string">    pub_date = DateField(label=&#x27;出版日期&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qyf__123/article/details/84992721">参考文章</a></p><h1 id="9-视图"><a href="#9-视图" class="headerlink" title="9. 视图"></a>9. 视图</h1><p>Django REST framwork 提供的视图的主要作用:</p><ul><li>控制序列化器的执行(检验、保存、转换数据)</li><li>控制数据库模型的操作</li></ul><p>REST framework 提供了众多的通用视图基类与扩展类, 以简化视图的编写.</p><h2 id="9-1、GenericAPIView-通用视图类"><a href="#9-1、GenericAPIView-通用视图类" class="headerlink" title="9.1、GenericAPIView[通用视图类]"></a>9.1、GenericAPIView[通用视图类]</h2><p>通用视图类主要作用就是把视图中的独特的代码抽取出来, 让视图方法中的代码更加通用, 方便把通用代码进行简写.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.generics.GenericAPIView</span><br></pre></td></tr></table></figure><p>继承自 <code>APIView</code> , <strong>主要增加了操作序列化器和数据库查询的方法, 作用是为下面Mixin扩展类的执行提供方法支持. 通常在使用时, 可搭配一个或多个Mixin扩展类.</strong></p><p><strong>提供的关于序列化器使用的属性与方法</strong></p><h4 id="1-get-serializer-class-self"><a href="#1-get-serializer-class-self" class="headerlink" title="(1)get_serializer_class(self)"></a>(1)get_serializer_class(self)</h4><p>当出现一个视图类中调用多个序列化器时, 那么可以通过条件判断在get_serializer_class方法中通过返回不同的序列化器类名就可以让视图方法执行不同的序列化器对象了.</p><p>返回序列化器类, 默认返回 <code>serializer_class</code> , 可以重写</p><h4 id="2-get-serializer-self-args-kwargs"><a href="#2-get-serializer-self-args-kwargs" class="headerlink" title="(2)get_serializer(self, *args, **kwargs)"></a>(2)get_serializer(self, *args, **kwargs)</h4><p>返回序列化器对象, 主要用来提供给Mixin扩展类使用, 如果我们在视图中想要获取序列化器对象, 也可以直接调用此方法.</p><p><strong>注意, 该方法在提供序列化器对象的时候, 会向序列化器对象的context属性补充三个数据:request、format、view, 这三个数据对象可以在定义序列化器时使用.</strong></p><ul><li><strong>request</strong> 当前视图的请求对象</li><li><strong>view</strong> 当前请求的类视图对象</li><li><strong>format</strong> 当前请求期望返回的数据格式</li></ul><h4 id="3-get-queryset-self"><a href="#3-get-queryset-self" class="headerlink" title="(3)get_queryset(self)"></a>(3)get_queryset(self)</h4><p>返回视图使用的查询集, 主要用来提供给Mixin扩展类使用, 是列表视图与详情视图获取数据的基础, 默认返回 <code>queryset</code> 属性, 可以重写, 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_queryset</span>(<span class="params">self</span>):</span><br><span class="line">    user = self.request.user</span><br><span class="line">    <span class="keyword">return</span> user.accounts.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><h4 id="4-get-object-self"><a href="#4-get-object-self" class="headerlink" title="(4)get_object(self)"></a>(4)get_object(self)</h4><p>返回详情视图所需的模型类数据对象, 主要用来提供给Mixin扩展类使用.</p><p>在试图中可以调用该方法获取详情信息的模型类对象.</p><p><strong>若详情访问的模型类对象不存在, 会返回404.</strong></p><p>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问.</p><p>举例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookDetailView.as_view()),&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(<span class="title class_ inherited__">GenericAPIView</span>):</span><br><span class="line">    queryset = BookInfo.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        book = self.get_object() <span class="comment"># get_object()方法根据pk参数查找queryset中的数据对象</span></span><br><span class="line">        serializer = self.get_serializer(book)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>其他可以设置的属性</p><ul><li><strong>pagination_class</strong> 指明分页控制类</li><li><strong>filter_backends</strong> 指明过滤控制后端</li></ul><p><strong>通用视图类的应用</strong></p><p>为了方便学习上面的GenericAPIView通用视图类, 我们新建一个子应用.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp gen</span><br></pre></td></tr></table></figure><p>路由:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;book/&#x27;</span>, views.BookView.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;book/(? P&lt;pk&gt;\d+)&#x27;</span>, views. BookDetailView.as_view()), </span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;设计增删改查查接口&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;序列化器&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">GenericAPIView</span>):</span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        bs = BookSerializer(instance=self.get_queryset(), many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(<span class="title class_ inherited__">GenericAPIView</span>):</span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        bs = BookSerializer(instance=self.get_object())</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        serializer = BookSerializer(instance=self.get_object(), data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        self.get_object().delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure><h2 id="9-2、5个视图扩展类"><a href="#9-2、5个视图扩展类" class="headerlink" title="9.2、5个视图扩展类"></a>9.2、5个视图扩展类</h2><p>也叫混入类(Mixin).</p><p>作用:</p><p>提供了几种后端视图(对数据资源进行增删改查)处理流程的实现, 如果需要编写的视图属于这五种, 则视图可以通过继承相应的扩展类来复用代码, 减少自己编写的代码量.</p><p>这五个扩展类需要搭配GenericAPIView通用视图基类, 因为五个扩展类的实现需要调用GenericAPIView提供的序列化器与数据库查询的方法.</p><h4 id="1-ListModelMixin"><a href="#1-ListModelMixin" class="headerlink" title="(1)ListModelMixin"></a>(1)ListModelMixin</h4><p>列表视图扩展类, 提供 <code>list(request, *args, **kwargs)</code> 方法快速实现列表视图, 返回200状态码.</p><p>该Mixin的list方法会对数据进行过滤和分页.</p><p>源代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListModelMixin</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>基于扩展类实现BookView:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sers.models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> .sers <span class="keyword">import</span> BookSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(GenericAPIView, ListModelMixin):</span><br><span class="line"></span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">list</span>(request)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（2）CreateModelMixin"><a href="#（2）CreateModelMixin" class="headerlink" title="（2）CreateModelMixin"></a>（2）CreateModelMixin</h4><p>创建视图扩展类，提供<code>create(request, *args, **kwargs)</code>方法快速实现创建资源的视图，成功返回201状态码。</p><p>如果序列化器对前端发送的数据验证失败，返回400错误。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CreateModelMixin</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_create(serializer)</span><br><span class="line">        headers = self.get_success_headers(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perform_create</span>(<span class="params">self, serializer</span>):</span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_success_headers</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&#x27;Location&#x27;</span>: <span class="built_in">str</span>(data[api_settings.URL_FIELD_NAME])&#125;</span><br><span class="line">        <span class="keyword">except</span> (TypeError, KeyError):</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>基于扩展类实现BookView:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(GenericAPIView, ListModelMixin, CreateModelMixin):</span><br><span class="line"></span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">list</span>(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> self.create(request)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（3）RetrieveModelMixin"><a href="#（3）RetrieveModelMixin" class="headerlink" title="（3）RetrieveModelMixin"></a>（3）RetrieveModelMixin</h4><p>详情视图扩展类，提供<code>retrieve(request, *args, **kwargs)</code>方法，可以快速实现返回一个存在的数据对象。</p><p>如果存在，返回200， 否则返回404。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RetrieveModelMixin</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Retrieve a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        serializer = self.get_serializer(instance)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>基于扩展类实现BookDetailView:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(GenericAPIView, RetrieveModelMixin):</span><br><span class="line"></span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, pk)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（4）UpdateModelMixin"><a href="#（4）UpdateModelMixin" class="headerlink" title="（4）UpdateModelMixin"></a>（4）UpdateModelMixin</h4><p>更新视图扩展类，提供<code>update(request, *args, **kwargs)</code>方法，可以快速实现更新一个存在的数据对象。</p><p>同时也提供<code>partial_update(request, *args, **kwargs)</code>方法，可以实现局部更新。</p><p>成功返回200，序列化器校验数据失败时，返回400错误。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdateModelMixin</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Update a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        partial = kwargs.pop(<span class="string">&#x27;partial&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        serializer = self.get_serializer(instance, data=request.data, partial=partial)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_update(serializer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">getattr</span>(instance, <span class="string">&#x27;_prefetched_objects_cache&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            <span class="string">&quot;&quot;&quot;If &#x27;prefetch_related&#x27; has been applied to a queryset, we need to</span></span><br><span class="line"><span class="string">            forcibly invalidate the prefetch cache on the instance.&quot;&quot;&quot;</span></span><br><span class="line">            instance._prefetched_objects_cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perform_update</span>(<span class="params">self, serializer</span>):</span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partial_update</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        kwargs[<span class="string">&#x27;partial&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request, *args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于扩展类实现BookDetailView:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(GenericAPIView, RetrieveModelMixin, UpdateModelMixin):</span><br><span class="line"></span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, pk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.update(request, pk)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="（5）DestroyModelMixin"><a href="#（5）DestroyModelMixin" class="headerlink" title="（5）DestroyModelMixin"></a>（5）DestroyModelMixin</h4><p>删除视图扩展类，提供<code>destroy(request, *args, **kwargs)</code>方法，可以快速实现删除一个存在的数据对象。</p><p>成功返回204，不存在返回404。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DestroyModelMixin</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Destroy a model instance.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">destroy</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        self.perform_destroy(instance)</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perform_destroy</span>(<span class="params">self, instance</span>):</span><br><span class="line">        instance.delete()</span><br></pre></td></tr></table></figure><p>基于扩展类实现BookDetailView:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin):</span><br><span class="line"></span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, pk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.update(request, pk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.destroy(request, pk)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整体代码，使用GenericAPIView结合视图扩展类，实现5个基本api接口，视图代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Create your views here.</span></span><br><span class="line"><span class="string">基于GenericAPIView结合5个视图扩展类完成基本的5个API接口</span></span><br><span class="line"><span class="string">ListModelMixin     提供了list方法，获取多条数据</span></span><br><span class="line"><span class="string">CreateModelMixin   提供了create方法，添加一条数据</span></span><br><span class="line"><span class="string">RetrieveModelMixin 提供了retrieve方法，获取一条数据</span></span><br><span class="line"><span class="string">UpdateModelMixin   提供了update方法，更新一条数据</span></span><br><span class="line"><span class="string">DestroyModelMixin   提供了destroy方法，删除一条数据</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;设计增删改查查接口&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;序列化器&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, \</span><br><span class="line">    DestroyModelMixin</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(GenericAPIView, ListModelMixin, CreateModelMixin):</span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">list</span>(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> self.create(request)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(GenericAPIView, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin):</span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request, pk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.update(request, pk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        <span class="keyword">return</span> self.destroy(request, pk)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>路由不变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    path(<span class="string">&#x27;books/&#x27;</span>, BookView.as_view()),</span><br><span class="line">    re_path(<span class="string">&#x27;books/(?P&lt;pk&gt;\d+)/&#x27;</span>, BookDetailView.as_view()),</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-3、-GenericAPIView的视图子类"><a href="#9-3、-GenericAPIView的视图子类" class="headerlink" title="9.3、 GenericAPIView的视图子类"></a>9.3、 GenericAPIView的视图子类</h2><h4 id="（1）CreateAPIView"><a href="#（1）CreateAPIView" class="headerlink" title="（1）CreateAPIView"></a>（1）CreateAPIView</h4><p>提供了post方法，内部调用了create方法</p><p>继承自： GenericAPIView、CreateModelMixin</p><h4 id="（2）ListAPIView"><a href="#（2）ListAPIView" class="headerlink" title="（2）ListAPIView"></a>（2）ListAPIView</h4><p>提供了get方法，内部调用了list方法</p><p>继承自：GenericAPIView、ListModelMixin</p><h4 id="（3）RetrieveAPIView"><a href="#（3）RetrieveAPIView" class="headerlink" title="（3）RetrieveAPIView"></a>（3）RetrieveAPIView</h4><p>提供了get方法，内部调用了retrieve方法</p><p>继承自: GenericAPIView、RetrieveModelMixin</p><h4 id="（4）DestoryAPIView"><a href="#（4）DestoryAPIView" class="headerlink" title="（4）DestoryAPIView"></a>（4）DestoryAPIView</h4><p>提供了delete方法，内部调用了destory方法</p><p>继承自：GenericAPIView、DestoryModelMixin</p><h4 id="（5）UpdateAPIView"><a href="#（5）UpdateAPIView" class="headerlink" title="（5）UpdateAPIView"></a>（5）UpdateAPIView</h4><p>提供了put和patch方法，内部调用了update和partial_update方法</p><p>继承自：GenericAPIView、UpdateModelMixin</p><h4 id="（6）ListCreateAPIView"><a href="#（6）ListCreateAPIView" class="headerlink" title="（6）ListCreateAPIView"></a>（6）ListCreateAPIView</h4><p>提供了get和post方法，内部调用了list和create方法</p><p>继承自：GenericAPIView、ListModelMixin、CreateModelMixin</p><h4 id="（7）RetrieveUpdateAPIView"><a href="#（7）RetrieveUpdateAPIView" class="headerlink" title="（7）RetrieveUpdateAPIView"></a>（7）RetrieveUpdateAPIView</h4><p>提供 get、put、patch方法</p><p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p><h4 id="（8）RetrieveDestoryAPIView"><a href="#（8）RetrieveDestoryAPIView" class="headerlink" title="（8）RetrieveDestoryAPIView"></a>（8）RetrieveDestoryAPIView</h4><p>提供 get、delete方法</p><p>继承自：GenericAPIView、RetrieveModelMixin、DestoryModelMixin</p><h4 id="（9）RetrieveUpdateDestoryAPIView"><a href="#（9）RetrieveUpdateDestoryAPIView" class="headerlink" title="（9）RetrieveUpdateDestoryAPIView"></a>（9）RetrieveUpdateDestoryAPIView</h4><p>提供 get、put、patch、delete方法</p><p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;设计增删改查查接口&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;序列化器&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Book</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> generics</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookDetailView</span>(generics.RetrieveUpdateDestroyAPIView):</span><br><span class="line">    queryset = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = BookSerializer</span><br></pre></td></tr></table></figure><h2 id="9-4、视图集"><a href="#9-4、视图集" class="headerlink" title="9.4、视图集"></a>9.4、视图集</h2><h3 id="9-4-1、ViewSet"><a href="#9-4-1、ViewSet" class="headerlink" title="9.4.1、ViewSet"></a>9.4.1、ViewSet</h3><p>继承自 <code>APIView</code> 与 <code>ViewSetMixin</code> , 作用也与APIView基本类似, 提供了身份认证、权限校验、流量管理等.</p><p>**ViewSet主要通过继承ViewSetMixin来实现在调用as_view()时传入字典{“http请求”:”视图方法”}的映射处理工作, 如{‘get’:’list’}, **</p><p>在ViewSet中, 没有提供任何动作action方法, 需要我们自己实现action方法.</p><p>使用视图集ViewSet, 可以将一系列视图相关的代码逻辑和相关的http请求动作封装到一个类中:</p><ul><li>list() 提供一组数据</li><li>retrieve() 提供单个数据</li><li>create() 创建数据</li><li>update() 保存数据</li><li>destory() 删除数据</li></ul><p>ViewSet视图集类不再限制视图方法名只允许get()、post()等这种情况了, 而是实现允许开发者根据自己的需要定义自定义方法名, 例如  list() 、create() 等, 然后经过路由中使用http和这些视图方法名进行绑定调用.</p><p>为了方便演示视图集的使用, 我们新建一个子应用, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp vset</span><br></pre></td></tr></table></figure><p>视图集只在使用as_view()方法的时候, 才会将<strong>action</strong>动作与具体请求方式对应上. 如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> vset.views <span class="keyword">import</span> BookView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;path(&quot;set&quot;, views.BookView.as_view(&#123;&quot;http请求&quot;:&quot;视图方法&quot;&#125;)),&#x27;&#x27;&#x27;</span></span><br><span class="line">    path(<span class="string">&quot;books/&quot;</span>, BookView.as_view(&#123;</span><br><span class="line">        <span class="string">&quot;get&quot;</span>: <span class="string">&quot;get_all_book&quot;</span>,</span><br><span class="line">        <span class="string">&quot;post&quot;</span>: <span class="string">&quot;add_book&quot;</span></span><br><span class="line">    &#125;)),</span><br><span class="line">    re_path(<span class="string">&quot;^books/(?P&lt;pk&gt;\d+)$&quot;</span>, BookView.as_view(&#123;</span><br><span class="line">        <span class="string">&quot;get&quot;</span>: <span class="string">&quot;get_one_book&quot;</span>,</span><br><span class="line">        <span class="string">&quot;put&quot;</span>: <span class="string">&quot;edit_book&quot;</span>,</span><br><span class="line">        <span class="string">&quot;delete&quot;</span>: <span class="string">&quot;delete&quot;</span>,</span><br><span class="line">    &#125;)),</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ViewSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sers.models <span class="keyword">import</span> Book</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Book</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">ViewSet</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_all_book</span>(<span class="params">self, request</span>):</span><br><span class="line"></span><br><span class="line">        books = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">        bs = BookSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_book</span>(<span class="params">self, request</span>):</span><br><span class="line">        bs = BookSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_one_book</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        book = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=book)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">edit_book</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        instance = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=instance, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        Book.objects.get(pk=pk).delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-4-2、GenericViewSet"><a href="#9-4-2、GenericViewSet" class="headerlink" title="9.4.2、GenericViewSet"></a>9.4.2、GenericViewSet</h3><p>继承自GenericAPIView和ViewSetMixin, 作用让视图集的视图代码变得更加通用, 抽离独特代码作为视图类的属性.</p><p>使用ViewSet通常并不方便, 因为list、retrieve、create、update、destory等方法都需要自己编写, 而这些方法与前面讲过的Mixin扩展类提供的方法同名, 所以我们可以通过继承Mixin扩展类来复用这些方法而无需自己编写. 但是Mixin扩展类依赖与 <code>GenericAPIView</code> , 所以还需要继承 <code>GenericAPIView</code> .</p><p><strong>GenericViewSet</strong>就帮助我们完成了这样的继承工作, 继承自 <code>GenericAPIView</code> 与 <code>ViewSetMixin</code> , 在实现了调用as_view()时传入字典(如 <code>&#123;&#39;get&#39;:&#39;list&#39;&#125;</code> )的映射处理工作的同时, 还提供了 <code>GenericAPIView</code> 提供的基础方法, 可以直接搭配Mixin扩展类使用.</p><p>视图代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">GenericViewSet</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):</span><br><span class="line"></span><br><span class="line">        books = Book.objects.<span class="built_in">all</span>()</span><br><span class="line">        bs = BookSerializer(instance=books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">self, request</span>):</span><br><span class="line">        bs = BookSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        book = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=book)</span><br><span class="line">        <span class="keyword">return</span> Response(bs.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        instance = Book.objects.get(pk=pk)</span><br><span class="line">        bs = BookSerializer(instance=instance, data=request.data)</span><br><span class="line">        <span class="keyword">if</span> bs.is_valid():</span><br><span class="line">            bs.save()</span><br><span class="line">            <span class="keyword">return</span> Response(bs.data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(bs.errors)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, request, pk</span>):</span><br><span class="line">        Book.objects.get(pk=pk).delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> vset.views <span class="keyword">import</span> BookView</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;path(&quot;set&quot;, views.BookView.as_view(&#123;&quot;http请求&quot;:&quot;视图方法&quot;&#125;)),&#x27;&#x27;&#x27;</span></span><br><span class="line">    path(<span class="string">&quot;books/&quot;</span>, BookView.as_view(&#123;</span><br><span class="line">        <span class="string">&quot;get&quot;</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line">        <span class="string">&quot;post&quot;</span>: <span class="string">&quot;create&quot;</span></span><br><span class="line">    &#125;)),</span><br><span class="line">    re_path(<span class="string">&quot;^books/(?P&lt;pk&gt;\d+)$&quot;</span>, BookView.as_view(&#123;</span><br><span class="line">        <span class="string">&quot;get&quot;</span>: <span class="string">&quot;retrieve&quot;</span>,</span><br><span class="line">        <span class="string">&quot;put&quot;</span>: <span class="string">&quot;update&quot;</span>,</span><br><span class="line">        <span class="string">&quot;delete&quot;</span>: <span class="string">&quot;delete&quot;</span>,</span><br><span class="line">    &#125;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>集合我们上面学习的模型扩展类, 实现简写操作, 视图, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, \</span><br><span class="line"></span><br><span class="line">    DestroyModelMixin</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(GenericViewSet, ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, </span><br><span class="line"></span><br><span class="line">                          DestroyModelMixin):</span><br><span class="line">    queryset = Book.objects</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-4-3、ModelViewSet和ReadOnlyModelViewSet"><a href="#9-4-3、ModelViewSet和ReadOnlyModelViewSet" class="headerlink" title="9.4.3、ModelViewSet和ReadOnlyModelViewSet"></a>9.4.3、ModelViewSet和ReadOnlyModelViewSet</h3><p>ModelViewSet继承自<code>GenericViewSet</code>，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p><p>ReadOnlyModelViewSet承自<code>GenericViewSet</code>，同时包括了ListModelMixin、RetrieveModelMixin。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Book.objects</span><br><span class="line">    serializer_class = BookSerializer</span><br></pre></td></tr></table></figure><h1 id="10-路由Routers"><a href="#10-路由Routers" class="headerlink" title="10. 路由Routers"></a>10. 路由Routers</h1><p>对于视图集ViewSet, 我们除了可以自己手动指明请求方式与动作action之间的对应关系外, 还可以使用Routers来帮助我们快速实现路由信息.</p><p>REST framework提供了两个router</p><ul><li><strong>SimpleRouter</strong></li><li><strong>DefaultRouter</strong></li></ul><h2 id="10-1-使用方法"><a href="#10-1-使用方法" class="headerlink" title="10.1 使用方法"></a>10.1 使用方法</h2><ol><li>创建router对象, 并注册视图集, 例如</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">&#x27;book&#x27;</span>, BookView, base_name=<span class="string">&#x27;book&#x27;</span>)</span><br></pre></td></tr></table></figure><p>register(prefix, viewset, base_name)</p><blockquote><ul><li>prefix 该视图集的路由前缀</li><li>viewset 视图集</li><li>base_name 路由别名的前缀</li></ul></blockquote><p>如上述代码会形成的路由如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^book/$    name: book-<span class="built_in">list</span></span><br><span class="line">^book/&#123;pk&#125;/$   name: book-detail</span><br></pre></td></tr></table></figure><p>2)添加路由数据</p><p>可以有两种方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">urlpatterns += router.urls</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;^&#x27;</span>, include(router.urls))</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>路由代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;使用drf提供路由类router给视图集生成路由列表&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;实例化路由类</span></span><br><span class="line"><span class="string">drf提供一共提供了两个路由类给我们使用,他们用法一致,功能几乎一样&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line">router = DefaultRouter()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;注册视图集&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;router.register(&quot;路由前缀&quot;,视图集类)&#x27;&#x27;&#x27;</span></span><br><span class="line">router.register(<span class="string">&quot;book&quot;</span>,views.BookView)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;把生成的路由列表追加到urlpatterns&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>( router.urls )</span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure><p>上面的代码就成功生成了路由地址[增&#x2F;删&#x2F;改&#x2F;查一条&#x2F;查多条的功能], 但是不会自动我们在视图集自定义方法的路由.</p><p>所以我们如果也要给自定义方法生成路由, 则需要进行action动作的声明.</p><h2 id="10-2-视图集中附加action的声明"><a href="#10-2-视图集中附加action的声明" class="headerlink" title="10.2 视图集中附加action的声明"></a>10.2 视图集中附加action的声明</h2><p>在视图集中, 如果想要让Router自动帮助我们为自定义的动作生成路由信息, 需要使用 <code>rest_framework.decorators.action</code> 装饰器.</p><p>以action装饰器装饰的方法名会作为action动作名, 与list、retrieve等同.</p><p>action装饰器可以接收两个参数:</p><ul><li><p><strong>methods</strong>: 声明该action对应的请求方式, 列表传递</p></li><li><p><strong>detail</strong>: 声明该action的路径是否与单一资源对应</p></li><li><p><strong>detail</strong>: 声明该action的路径是否与单一资源对应</p></li><li><p><strong>detail</strong>: 声明该action的路径是否与单一资源对应</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由前缀/&lt;pk&gt;/action方法名/</span><br></pre></td></tr></table></figure><ul><li>True 表示路径格式是<code>xxx/&lt;pk&gt;/action方法名/</code></li><li>False 表示路径格式是<code>xxx/action方法名/</code></li></ul><ul><li>url_path: 声明该action的路由尾缀.</li></ul><p>举例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookView</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Book.objects</span><br><span class="line">    serializer_class = BookSerializer</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    action装饰器的作用：告诉路由类给视图集的自定义方法生成路由信息</span></span><br><span class="line"><span class="string">    methods, 列表，允许哪些http请求能访问当前视图方法</span></span><br><span class="line"><span class="string">    detail，布尔，生成路由时是否拼接pk参数</span></span><br><span class="line"><span class="string">            detail为True，表示路径名格式应该为 book/&#123;pk&#125;/login/</span></span><br><span class="line"><span class="string">    url_path，字符串，生成路由时末尾路由路径，如果没有声明，则自动以当前方法名作为路由尾缀</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @action(<span class="params">methods=[<span class="string">&#x27;get&#x27;</span>], detail=<span class="literal">True</span>,url_path=<span class="string">&quot;login&quot;</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self, request,pk</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;登录&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&quot;msg&quot;</span>:request.method&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;detail为False 表示路径名格式应该为 book/get_new_5/&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">    @action(<span class="params">methods=[<span class="string">&#x27;get&#x27;</span>], detail=<span class="literal">False</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_new_5</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取最新添加的5本书&quot;&quot;&quot;</span></span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由路由器自动为此视图集自定义action方法形成的路由会是如下内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^book/get_new_5/$    name: book-get_new_5</span><br><span class="line">^book/&#123;pk&#125;/login/$   name: book-login</span><br></pre></td></tr></table></figure><h2 id="10-3-路由router形成URL的方式"><a href="#10-3-路由router形成URL的方式" class="headerlink" title="10.3 路由router形成URL的方式"></a>10.3 路由router形成URL的方式</h2><ol><li>SimpleRouter(prefix&#x3D;”路由前缀”, viewset&#x3D;视图集类, basename&#x3D;”路由别名”)</li></ol><img src="/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/SimpleRouter-16318481562175.png" class="" title="SimpleRouter"><p>2)DefaultRouter</p><img src="/2024/07/01/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/DefaultRouter-16318481562186.png" class="" title="DefaultRouter"><p>DefaultRouter与SimpleRouter的区别是, DefaultRouter会多附带一个默认的API根视图, 返回一个包含所有列表视图的超链接响应数据.</p><h1 id="11、其它功能组件"><a href="#11、其它功能组件" class="headerlink" title="11、其它功能组件"></a>11、其它功能组件</h1><p>为了方便接下来的学习, 我们创建一个新的子应用 opt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp opt</span><br></pre></td></tr></table></figure><p>注册子应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;opt&#x27;</span>,     <span class="comment"># drf提供的组件使用</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>总路由, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;students/&#x27;</span>, include(<span class="string">&quot;students.urls&quot;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;sers/&#x27;</span>, include(<span class="string">&quot;sers.urls&quot;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;school/&#x27;</span>, include(<span class="string">&quot;school.urls&quot;</span>)),</span><br><span class="line">    path(<span class="string">&quot;req/&quot;</span>, include(<span class="string">&quot;req.urls&quot;</span>)),</span><br><span class="line">    path(<span class="string">&quot;demo/&quot;</span>, include(<span class="string">&quot;demo.urls&quot;</span>)),</span><br><span class="line">    path(<span class="string">&quot;opt/&quot;</span>, include(<span class="string">&quot;opt.urls&quot;</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子路由, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>因为接下来的认证组件中需要使用到登陆功能, 所以我们使用django内置admin站点并创建一个管理员.</p><p>admin运营站点的访问地址:<a href="http://127.0.0.1:8000/admin">http://127.0.0.1:8000/admin</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line">&#x27;&#x27;&#x27;如果之前有账号，但是忘了，可以通过终端下的命令修改指定用户的密码，这里的密码必须8位长度以上的&#x27;&#x27;&#x27;</span><br><span class="line">python manage.py changepassword 用户名</span><br></pre></td></tr></table></figure><p>创建管理员以后, 访问admin站点, 先修改站点的语言配置</p><p>settings.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = &#x27;zh-hans&#x27;</span><br><span class="line"></span><br><span class="line">TIME_ZONE = &#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure><h2 id="11-1-认证Authentication"><a href="#11-1-认证Authentication" class="headerlink" title="11.1. 认证Authentication"></a>11.1. 认证Authentication</h2><p>可以在配置文件中配置全局默认的认证方案</p><p>常见的认证方式:cookie、session、token</p><p>&#x2F;home&#x2F;moluo&#x2F;.virtualenvs&#x2F;drfdemo&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#x2F;rest_framework&#x2F;settings.py 默认配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>, <span class="comment"># session认证</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,   <span class="comment"># 基本认证</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在具体的视图类中通过设置authentication_classess类属性来设置单独的不同的认证方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication, BasicAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    authentication_classes = [SessionAuthentication, BasicAuthentication]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,request</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>认证失败会有两种可能的返回值, 这个需要我们配合权限组件来使用:</p><ul><li>401 Unauthorized 未认证</li><li>403 Permission Denied 权限被禁止</li></ul><p>自定义认证, <code>drfdemo.authentication</code> 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.exceptions <span class="keyword">import</span> APIException</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomAuthentication</span>(<span class="title class_ inherited__">BaseAuthentication</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义认证方式</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">authenticate</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;:::&quot;</span>)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        认证方法</span></span><br><span class="line"><span class="string">        request: 本次客户端发送过来的http请求对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;token = request.query_params.get(&quot;token&quot;)&#x27;&#x27;&#x27;</span></span><br><span class="line">        token = request._request.META.get(<span class="string">&quot;HTTP_TOKEN&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">&quot;123456789&quot;</span>:</span><br><span class="line">            <span class="keyword">raise</span> APIException(<span class="string">&quot;认证失败&quot;</span>)</span><br><span class="line">        user = <span class="string">&quot;root&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (user,token)  <span class="comment"># 按照固定的返回格式填写 （用户模型对象, None）</span></span><br></pre></td></tr></table></figure><p>视图调用自定义认证, 视图代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AnonymousUser</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication</span><br><span class="line"><span class="keyword">from</span> drfdemo.authentication <span class="keyword">import</span> CustomAuthentication</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeAPIView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;authentication_classes = [CustomAuthentication, ]&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,request</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;单独设置认证方式&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(request.user) <span class="comment"># 在中间件AuthenticationMiddleware中完成用户身份识别的，如果没有登录request.user值为AnonymousUser</span></span><br><span class="line">        <span class="keyword">if</span> request.user.<span class="built_in">id</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(<span class="string">&quot;未登录用户：游客&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(<span class="string">f&quot;已登录用户：<span class="subst">&#123;request.user&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然, 也可以注释掉上面视图中的配置, 改成全局配置.settings.py, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;drf配置信息必须全部写在REST_FRAMEWORK配置项中&quot;&quot;&quot;</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;配置认证方式的选项【drf的认证是内部循环遍历每一个注册的认证类，一旦认证通过识别到用户身份，则不会继续循环】&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;drfdemo.authentication.CustomAuthentication&#x27;</span>,          <span class="comment"># 自定义认证</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,  <span class="comment"># session认证</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,    <span class="comment"># 基本认证</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-权限Permissions"><a href="#11-2-权限Permissions" class="headerlink" title="11.2. 权限Permissions"></a>11.2. 权限Permissions</h2><p>权限控制可以限制用户对于视图的访问和对于具有模型对象的访问.</p><ul><li>在执行视图的as_view()方法的dispatch()方法前, 会先进行视图访问权限的判断</li><li>在通过get_object()获取具体模型对象时, 会进行模型对象访问权限的判断</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>可以在配置文件中<strong>全局设置</strong>默认的权限管理类, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未指明, 则采用如下默认配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">   <span class="string">&#x27;rest_framework.permissions.AllowAny&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也可以在具体的视图中通过permission_classes属性来进行局部设置, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="提供的权限"><a href="#提供的权限" class="headerlink" title="提供的权限"></a>提供的权限</h3><ul><li>AllowAny 允许所有用户, 默认权限</li><li>IsAuthenticated 仅通过登录认证的用户</li><li>IsAdminUser 仅管理员用户</li><li>IsAuthenticatedOrReadOnly 已经登陆认证的用户可以对数据进行增删改操作, 没有登陆认证的只能查看数据.</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> RetrieveAPIView</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VulnAPIView</span>(<span class="title class_ inherited__">RetrieveAPIView</span>):</span><br><span class="line">    queryset = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = VulnSerializer</span><br><span class="line">    authentication_classes = [SessionAuthentication]</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br></pre></td></tr></table></figure><h3 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h3><p>如需自定义权限, 需继承rest_framework.permissions. BasePermission父类, 并实现以下两个任何一个方法或全部</p><ul><li><p><code>.has_permission(self, request, view)</code></p><p>是否可以访问视图, view表示当前视图对象</p></li><li><p><code>.has_object_permission(self, request, view, obj)</code></p><p>是否可以访问模型对象, view表示当前视图, obj为模型数据对象</p></li></ul><p>例如:</p><p>在当前子应用下, 创建一个权限文件drfdemo.permissions.py中声明自定义权限类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsXiaoMingPermission</span>(<span class="title class_ inherited__">BasePermission</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义权限，可用于全局配置，也可以用于局部</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_permission</span>(<span class="params">self, request, view</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        视图权限</span></span><br><span class="line"><span class="string">        返回结果未True则表示允许访问视图类</span></span><br><span class="line"><span class="string">        request: 本次客户端提交的请求对象</span></span><br><span class="line"><span class="string">        view: 本次客户端访问的视图类</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        role = request.query_params.get(<span class="string">&quot;role&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> role == <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_object_permission</span>(<span class="params">self, request, view, obj</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        模型权限</span></span><br><span class="line"><span class="string">        返回结果为True则表示允许操作模型对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>视图代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .permissions <span class="keyword">import</span> IsXiaoMingPermission</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = StudentSerializer</span><br><span class="line">    permission_classes = [IsXiaoMingPermission] <span class="comment"># 自定义权限</span></span><br></pre></td></tr></table></figure><p>认证和权限的举例代码:</p><p>settings.py, 全局配置, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;关于REST_FRAMEWORK的所有配置项都是填写在django的settings配置文件中的。</span></span><br><span class="line"><span class="string">所有的REST_FRAMEWORK都要填写在 REST_FRAMEWORK的配置项，而且配置只能大写！！&#x27;&#x27;&#x27;</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;认证全局配置&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>:[</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;默认由drf提供的认证方式&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,  <span class="comment"># session认证</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,   <span class="comment"># 基本认证</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;将来开发中，我们还可以自己实现属于自己项目的认证方式&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="string">&#x27;drfdemo.authentications.CustomAuthentication&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;权限全局配置&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置所有视图只能被已经登录认证过的用户访问&quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> student.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> student.serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> drfdemo.authentications <span class="keyword">import</span> CustomAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated,IsAdminUser,IsAuthenticatedOrReadOnly</span><br><span class="line"><span class="keyword">from</span> drfdemo.permissions <span class="keyword">import</span> IsXiaoMingPermission</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student1ModelViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Student.objects</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"><span class="string">&quot;&quot;&quot;    # 局部认证配置方式&quot;&quot;&quot;</span></span><br><span class="line">    authentication_classes = [SessionAuthentication,CustomAuthentication]</span><br><span class="line"><span class="string">&quot;&quot;&quot;    # 局部权限配置方式</span></span><br><span class="line"><span class="string">    # permission_classes = [IsAuthenticated] # 只要经过认证登录就可以访问</span></span><br><span class="line"><span class="string">    # permission_classes = [IsAdminUser] # 只要是站点管理员就可以访问</span></span><br><span class="line"><span class="string">    # permission_classes = [IsAuthenticatedOrReadOnly] # 登录用户可以访问视图的增删查改页面，未登录的游客只能查看数据。不能修改！</span></span><br><span class="line"><span class="string">    # permission_classes = [] # 取消权限判断识别&quot;&quot;&quot;</span></span><br><span class="line">    permission_classes = [IsXiaoMingPermission] <span class="comment"># 自定义权限</span></span><br></pre></td></tr></table></figure><p>自定义认证类, <code>drfdemo.authentications</code> , 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication,BaseAuthentication</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomAuthentication</span>(<span class="title class_ inherited__">BaseAuthentication</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义认证</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">authenticate</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        认证方法</span></span><br><span class="line"><span class="string">        request: 本次客户端发送过来的http请求对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        role = request.query_params.get(<span class="string">&quot;role&quot;</span>)</span><br><span class="line">        root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> role == <span class="string">&quot;root&quot;</span>:</span><br><span class="line">            root = User.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> (root,<span class="literal">None</span>) <span class="comment"># 按照固定的返回格式填写 （用户模型对象, None）</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>自定义权限类, <code>defdemo.permissions</code> , 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsXiaoMingPermission</span>(<span class="title class_ inherited__">BasePermission</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义权限，可用于全局配置，也可以用于局部</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_permission</span>(<span class="params">self, request, view</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        视图权限</span></span><br><span class="line"><span class="string">        返回结果未True则表示允许访问视图类</span></span><br><span class="line"><span class="string">        request: 本次客户端提交的请求对象</span></span><br><span class="line"><span class="string">        view: 本次客户端访问的视图类</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        role = request.query_params.get(<span class="string">&quot;role&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> role == <span class="string">&quot;xiaoming&quot;</span> <span class="comment"># 认证的结果必须返回True或者False，表示是否有权限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_object_permission</span>(<span class="params">self, request, view, obj</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        模型权限</span></span><br><span class="line"><span class="string">        返回结果未True则表示允许操作模型对象</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>urls, 路由代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> SimpleRouter</span><br><span class="line">router = SimpleRouter()</span><br><span class="line">router.register(<span class="string">&quot;stu1&quot;</span>, views.Student1ModelViewSet,)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&quot;&quot;</span>, include(router.urls)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="11-3-限流Throttling"><a href="#11-3-限流Throttling" class="headerlink" title="11.3. 限流Throttling"></a>11.3. 限流Throttling</h2><p>可以对接口访问的频次进行限制, 以减轻服务器压力, 或者实现特定的业务.</p><p>一般用于付费购买次数, 投票等场景使用.</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>可以在配置文件中, 使用 <code>DEFAULT_THROTTLE_CLASSES</code> 和 <code>DEFAULT_THROTTLE_RATES</code> 进行全局配置, </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line"><span class="string">&quot;&quot;&quot;    # 限流全局配置</span></span><br><span class="line"><span class="string">    # &#x27;DEFAULT_THROTTLE_CLASSES&#x27;:[ # 限流配置类</span></span><br><span class="line"><span class="string">    #     &#x27;rest_framework.throttling.AnonRateThrottle&#x27;, # 未认证用户[未登录用户]</span></span><br><span class="line"><span class="string">    #     &#x27;rest_framework.throttling.UserRateThrottle&#x27;, # 已认证用户[已登录用户]</span></span><br><span class="line"><span class="string">    # ],&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>:&#123; <span class="comment"># 频率配置</span></span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;2/day&#x27;</span>,  <span class="comment"># 针对游客的访问频率进行限制，实际上，drf只是识别首字母，但是为了提高代码的维护性，建议写完整单词</span></span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;5/day&#x27;</span>, <span class="comment"># 针对会员的访问频率进行限制，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DEFAULT_THROTTLE_RATES</code> 可以使用 <code>second</code> , <code>minute</code> , <code>hour</code> 或 <code>day</code> 来指明周期.</p><p>也可以在具体视图中通过throttle_classess属性来配置, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> UserRateThrottle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2ModelViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Student.objects</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 限流局部配置[这里需要配合在全局配置中的DEFAULT_THROTTLE_RATES来设置频率]&quot;&quot;&quot;</span></span><br><span class="line">    throttle_classes = [UserRateThrottle]</span><br></pre></td></tr></table></figure><h3 id="可选限流类"><a href="#可选限流类" class="headerlink" title="可选限流类"></a>可选限流类</h3><ol><li>AnonRateThrottle</li></ol><p>限制所有匿名未认证用户, 使用IP区分用户.【很多公司这样的, IP结合设备信息来判断, 当然比IP要靠谱一点点而已】</p><p>使用 <code>DEFAULT_THROTTLE_RATES[&#39;anon&#39;]</code> 来设置频次</p><p>2)UserRateThrottle</p><p>限制认证用户, 使用User模型的 id主键 来区分.</p><p>使用 <code>DEFAULT_THROTTLE_RATES[&#39;user&#39;]</code> 来设置频次</p><p>3)ScopedRateThrottle</p><p>限制用户对于每个视图的访问频次, 使用ip或user id.</p><p>settings.py, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 限流全局配置&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>:[ <span class="comment"># 限流配置类</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;#     &#x27;rest_framework.throttling.AnonRateThrottle&#x27;, # 未认证用户[未登录用户]</span></span><br><span class="line"><span class="string">    #     &#x27;rest_framework.throttling.UserRateThrottle&#x27;, # 已认证用户[已登录用户]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.ScopedRateThrottle&#x27;</span>, <span class="comment"># 自定义限流</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>:&#123; <span class="comment"># 频率配置</span></span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;2/day&#x27;</span>,  <span class="comment"># 针对游客的访问频率进行限制，实际上，drf只是识别首字母，但是为了提高代码的维护性，建议写完整单词</span></span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;5/day&#x27;</span>, <span class="comment"># 针对会员的访问频率进行限制，</span></span><br><span class="line">        <span class="string">&#x27;vip&#x27;</span>: <span class="string">&#x27;10/day&#x27;</span>, <span class="comment"># 针对会员的访问频率进行限制，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> UserRateThrottle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2ModelViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Student.objects</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 限流局部配置[这里需要配合在全局配置中的DEFAULT_THROTTLE_RATES来设置频率]</span></span><br><span class="line"><span class="string">    # throttle_classes = [UserRateThrottle] # 使用drf限流类来配置频率&quot;&quot;&quot;</span></span><br><span class="line">    throttle_scope = <span class="string">&quot;vip&quot;</span> <span class="comment"># 自定义频率</span></span><br></pre></td></tr></table></figure><h2 id="11-4-过滤Filtering"><a href="#11-4-过滤Filtering" class="headerlink" title="11.4. 过滤Filtering"></a>11.4. 过滤Filtering</h2><p>对于列表数据可能需要根据字段进行过滤, 我们可以通过添加django-fitlter扩展来增强支持.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-filter</span><br></pre></td></tr></table></figure><p>在配置文件中增加过滤后端的设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;django_filters&#x27;</span>,  <span class="comment"># 需要注册应用，</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&#x27;DEFAULT_FILTER_BACKENDS&#x27;</span>: (<span class="string">&#x27;django_filters.rest_framework.DjangoFilterBackend&#x27;</span>,)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在视图类中添加类属性filter_fields, 指定可以过滤的字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentListView</span>(<span class="title class_ inherited__">ListAPIView</span>):</span><br><span class="line">    queryset = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = StudentSerializer</span><br><span class="line">    filter_fields = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-5-排序Ordering"><a href="#11-5-排序Ordering" class="headerlink" title="11.5. 排序Ordering"></a>11.5. 排序Ordering</h2><p>对于列表数据, REST framework提供了<strong>OrderingFilter</strong>过滤器来帮助我们快速指明数据按照指定字段进行排序.</p><p>使用方法:</p><p>在类视图中设置filter_backends, 使用 <code>rest_framework.filters.OrderingFilter</code> 过滤器, REST framework会在请求的查询字符串参数中检查是否包含了ordering参数, 如果包含了ordering参数, 则按照ordering参数指明的排序字段对数据集进行排序.</p><p>前端可以传递的ordering参数的可选字段值需要在ordering_fields中指明.</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentListView</span>(<span class="title class_ inherited__">ListAPIView</span>):</span><br><span class="line">    queryset = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    filter_backends = [OrderingFilter]</span><br><span class="line">    ordering_fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;# 127.0.0.1:8000/books/?ordering=-age</span></span><br><span class="line"><span class="string"># -id 表示针对id字段进行倒序排序</span></span><br><span class="line"><span class="string"># id  表示针对id字段进行升序排序&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>如果需要在过滤以后再次进行排序, 则需要两者结合!</p><p>全局配置下的过滤组件不能和排序组件一起使用, 只支持局部配置的过滤组件和排序组件一起使用.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> ListAPIView</span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student3ListView</span>(<span class="title class_ inherited__">ListAPIView</span>):</span><br><span class="line">    queryset = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    filter_fields = [<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>]</span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 因为局部配置会覆盖全局配置,所以需要重新把过滤组件核心类再次声明,</span></span><br><span class="line"><span class="string">    # 否则过滤功能会失效&quot;&quot;&quot;</span></span><br><span class="line">    filter_backends = [OrderingFilter,DjangoFilterBackend]</span><br><span class="line">    ordering_fields = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="11-6-分页Pagination"><a href="#11-6-分页Pagination" class="headerlink" title="11.6. 分页Pagination"></a>11.6. 分页Pagination</h2><p>因为django默认提供的分页器主要使用于前后端不分离的业务场景, 所以REST framework也提供了分页的支持.</p><p>我们可以在配置文件中设置全局的分页方式, 如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>:  <span class="string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PAGE_SIZE&#x27;</span>: <span class="number">100</span>  <span class="comment"># 每页数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;# 如果在配置settings.py文件中， 设置了全局分页，那么在drf中凡是调用了ListModelMixin的list()，都会自动分页。如果项目中出现大量需要分页的数据，只有少数部分的分页，则可以在少部分的视图类中关闭分页功能。</span></span><br><span class="line"><span class="string"># 另外，视图类在使用过分页以后，务必在编写queryset属性时，模型.objects后面调用结果。例如：</span></span><br><span class="line"><span class="string"># Student.objects.all()&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student3ModelViewSet</span>(<span class="title class_ inherited__">ListAPIView</span>):</span><br><span class="line">pagination_class = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>也可通过自定义Pagination类, 来为视图添加不同分页行为. 在视图中通过 <code>pagination_clas</code> 属性来指明.</p><p>可选分页器:</p><ol><li><strong>PageNumberPagination</strong></li></ol><p>前端访问网址形式:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  http://127.0.0.1:8000/students/?page=4</span><br></pre></td></tr></table></figure><p>可以在子类中定义的属性:</p><ul><li>page_size 每页数目</li><li>page_query_param 前端发送的页数关键字名, 默认为”page”</li><li>page_size_query_param 前端发送的每页数目关键字名, 默认为None</li><li>max_page_size 前端最多能设置的每页数量</li></ul><p>分页器类, <code>paginations</code> , 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  rest_framework.pagination <span class="keyword">import</span> PageNumberPagination,LimitOffsetPagination</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentPageNumberPagination</span>(<span class="title class_ inherited__">PageNumberPagination</span>):</span><br><span class="line">    page_query_param = <span class="string">&quot;page&quot;</span> <span class="comment"># 查询字符串中代表页码的变量名</span></span><br><span class="line">    page_size_query_param = <span class="string">&quot;size&quot;</span> <span class="comment"># 查询字符串中代表每一页数据的变量名</span></span><br><span class="line">    page_size = <span class="number">2</span> <span class="comment"># 每一页的数据量</span></span><br><span class="line">    max_page_size = <span class="number">4</span> <span class="comment"># 允许客户端通过查询字符串调整的最大单页数据量</span></span><br></pre></td></tr></table></figure><p>视图, <code>views</code> , 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .paginations <span class="keyword">import</span> StudentPageNumberPagination,StudentLimitOffsetPagination</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student3ModelViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 取消当前视图类的分页效果</span></span><br><span class="line"><span class="string">    # pagination_class = None</span></span><br><span class="line"><span class="string">    # 局部分页&quot;&quot;&quot;</span></span><br><span class="line">    pagination_class = StudentPageNumberPagination</span><br></pre></td></tr></table></figure><p>2)<strong>LimitOffsetPagination</strong></p><p>前端访问网址形式:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://127.0.0.1/four/students/?limit=100&amp;offset=100</span><br></pre></td></tr></table></figure><p>可以在子类中定义的属性:</p><ul><li>default_limit 默认限制, 默认值与<code>PAGE_SIZE</code>设置一直</li><li>limit_query_param limit参数名, 默认’limit’</li><li>offset_query_param offset参数名, 默认’offset’</li><li>max_limit 最大limit限制, 默认None</li></ul><p>分页类, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  rest_framework.pagination <span class="keyword">import</span> PageNumberPagination,LimitOffsetPagination</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentLimitOffsetPagination</span>(<span class="title class_ inherited__">LimitOffsetPagination</span>):</span><br><span class="line">    limit_query_param = <span class="string">&quot;limit&quot;</span> <span class="comment"># 查询字符串中代表每一页数据的变量名</span></span><br><span class="line">    offset_query_param = <span class="string">&quot;offset&quot;</span> <span class="comment"># 查询字符串中代表页码的变量名</span></span><br><span class="line">    default_limit = <span class="number">2</span> <span class="comment"># 每一页的数据量</span></span><br><span class="line">    max_limit = <span class="number">4</span> <span class="comment"># 允许客户端通过查询字符串调整的最大单页数据量</span></span><br></pre></td></tr></table></figure><p>视图, <code>views</code> , 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .paginations <span class="keyword">import</span> StudentPageNumberPagination,StudentLimitOffsetPagination</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student3ModelViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    pagination_class = StudentLimitOffsetPagination</span><br></pre></td></tr></table></figure><h2 id="11-7-异常处理-Exceptions"><a href="#11-7-异常处理-Exceptions" class="headerlink" title="11.7. 异常处理 Exceptions"></a>11.7. 异常处理 Exceptions</h2><p>REST framework提供了异常处理, 我们可以自定义异常处理函数. 例如我们想在要创建一个自定义异常函数, </p><p>这个函数, 我们保存到当前子应用opt中[注意, 开发时, 我们会找个独立的公共目录来保存这种公共的函数&#x2F;工具&#x2F;类库].</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_exception_handler</span>(<span class="params">exc, context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 先调用REST framework默认的异常处理方法获得标准错误响应对象&quot;&quot;&quot;</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 在此处补充自定义的异常处理&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        response.data[<span class="string">&#x27;status_code&#x27;</span>] = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>在配置文件中声明自定义的异常处理, <code>settings</code> , 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="string">&#x27;drfdemo.exceptions.custom_excetion_handle&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未声明, 会采用默认的方式, 如下</p><p>rest_frame&#x2F;settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="string">&#x27;rest_framework.views.exception_handler&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如:</p><p>补充上处理关于数据库的异常, 这里使用其他异常来举例:</p><p><code>主应用.exceptions</code> , 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;# 自定义异常函数: 在drf本身提供的异常函数基础上，我们增加更多的异常处理就可以了。&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> DatabaseError</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_excetion_handle</span>(<span class="params">exc, context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    自定义异常函数，必须要在配置文件中注册才能被drf使用</span></span><br><span class="line"><span class="string">    exc: 异常对象，本次发生的异常对象</span></span><br><span class="line"><span class="string">    context: 字典，本次发生异常时，python解析器提供的执行上下文</span></span><br><span class="line"><span class="string">    所谓的执行上下文[context]，就是程序执行到当前一行代码时，能提供给开发者调用的环境信息异常发生时，代码所在的路径，时间，视图，客户端http请求等等...]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 先让drf处理它能识别的异常&quot;&quot;&quot;</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;# 在经过了drf的异常处理以后，还是返回None则表示有2种情况:&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;# 异常发生时的视图对象&quot;&quot;&quot;</span></span><br><span class="line">        view = context[<span class="string">&#x27;view&#x27;</span>]</span><br><span class="line">        <span class="string">&quot;&quot;&quot;# 异常发生时的http请求&quot;&quot;&quot;</span></span><br><span class="line">        request = context[<span class="string">&quot;request&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, DatabaseError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;[%s]: %s&#x27;</span> % (view, exc))</span><br><span class="line">            response = Response(&#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;服务器内部错误&#x27;</span>&#125;, status=status.HTTP_507_INSUFFICIENT_STORAGE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, TypeError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0不能作为除数~&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(request)</span><br><span class="line">            response = Response(&#123;<span class="string">&#x27;detail&#x27;</span>: <span class="string">&#x27;0不能作为除数&#x27;</span>&#125;, status=status.HTTP_500_INTERNAL_SERVER_ERROR)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>视图中, 故意报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .paginations <span class="keyword">import</span> StudentPageNumberPagination,StudentLimitOffsetPagination</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student3ModelViewSet</span>(<span class="title class_ inherited__">ModelViewSet</span>):</span><br><span class="line">    queryset = Student.objects  <span class="comment"># 去掉 .all()，就会报错。</span></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    pagination_class = StudentPageNumberPagination</span><br></pre></td></tr></table></figure><h3 id="REST-framework定义的异常"><a href="#REST-framework定义的异常" class="headerlink" title="REST framework定义的异常"></a>REST framework定义的异常</h3><ul><li>APIException 所有异常的父类</li><li>ParseError 解析错误</li><li>AuthenticationFailed 认证失败</li><li>NotAuthenticated 尚未认证</li><li>PermissionDenied 权限决绝</li><li>NotFound 未找到</li><li>MethodNotAllowed 请求方式不支持</li><li>NotAcceptable 要获取的数据格式不支持</li><li>Throttled 超过限流次数</li><li>ValidationError 校验失败</li></ul><p>也就是说, 很多的没有在上面列出来的异常, 就需要我们在自定义异常中自己处理了.</p><h2 id="11-8-自动生成接口文档"><a href="#11-8-自动生成接口文档" class="headerlink" title="11.8. 自动生成接口文档"></a>11.8. 自动生成接口文档</h2><p>REST framework可以自动帮助我们生成接口文档.</p><p>接口文档以网页的方式呈现.</p><p>自动接口文档能生成的是继承自 <code>APIView</code> 及其子类的视图.</p><h3 id="11-8-1-安装依赖"><a href="#11-8-1-安装依赖" class="headerlink" title="11.8.1. 安装依赖"></a>11.8.1. 安装依赖</h3><p>REST framewrok生成接口文档需要 <code>coreapi</code> 库的支持.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install coreapi</span><br></pre></td></tr></table></figure><h3 id="11-8-2-设置接口文档访问路径"><a href="#11-8-2-设置接口文档访问路径" class="headerlink" title="11.8.2. 设置接口文档访问路径"></a>11.8.2. 设置接口文档访问路径</h3><p>在总路由中添加接口文档路径.</p><p>文档路由对应的视图配置为 <code>rest_framework.documentation.include_docs_urls</code> , </p><p>参数 <code>title</code> 为接口文档网站的标题. 总路由, 代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.documentation <span class="keyword">import</span> include_docs_urls</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">&#x27;docs/&#x27;</span>, include_docs_urls(title=<span class="string">&#x27;站点页面标题&#x27;</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在settings.py中配置接口文档.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_SCHEMA_CLASS&#x27;</span>: <span class="string">&#x27;rest_framework.schemas.AutoSchema&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-8-3-文档描述说明的定义位置"><a href="#11-8-3-文档描述说明的定义位置" class="headerlink" title="11.8.3. 文档描述说明的定义位置"></a>11.8.3. 文档描述说明的定义位置</h3><ol><li>单一方法的视图, 可直接使用类视图的文档字符串, 如</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookListView</span>(generics.ListAPIView):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回所有图书信息.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>2)包含多个方法的视图, 在类视图的文档字符串中, 分开方法定义, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookListCreateView</span>(generics.ListCreateAPIView):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    get:</span></span><br><span class="line"><span class="string">    返回所有图书信息.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    post:</span></span><br><span class="line"><span class="string">    新建图书.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>3)对于视图集ViewSet, 仍在类视图的文档字符串中封开定义, 但是应使用action名称区分, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BookInfoViewSet</span>(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    list:</span></span><br><span class="line"><span class="string">    返回图书列表数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    retrieve:</span></span><br><span class="line"><span class="string">    返回图书详情数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    latest:</span></span><br><span class="line"><span class="string">    返回最新的图书数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    read:</span></span><br><span class="line"><span class="string">    修改图书的阅读量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="11-8-4-访问接口文档网页"><a href="#11-8-4-访问接口文档网页" class="headerlink" title="11.8.4. 访问接口文档网页"></a>11.8.4. 访问接口文档网页</h3><p>浏览器访问 127.0.0.1:8000&#x2F;docs&#x2F;, 即可看到自动生成的接口文档.</p><p><img src="/DRF%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E9%A1%B5%E9%9D%A2.png" alt="æ¥å£ææ¡£ç½é¡µ"></p><p>两点说明:</p><ol><li>视图集ViewSet中的retrieve名称, 在接口文档网站中叫做read</li></ol><p>2)参数的Description需要在模型类或序列化器类的字段中以help_text选项定义, 如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    age = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">&#x27;年龄&#x27;</span>, help_text=<span class="string">&#x27;年龄&#x27;</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Student</span><br><span class="line">        fields = <span class="string">&quot;__all__&quot;</span></span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">&#x27;age&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;required&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">&#x27;help_text&#x27;</span>: <span class="string">&#x27;年龄&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=3 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#drf%E7%BB%84%E4</summary>
      
    
    
    
    <category term="技术" scheme="https://champion-yang.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Django" scheme="https://champion-yang.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>hexo建站</title>
    <link href="https://champion-yang.github.io/2024/06/28/hexo%E5%BB%BA%E7%AB%99/"/>
    <id>https://champion-yang.github.io/2024/06/28/hexo%E5%BB%BA%E7%AB%99/</id>
    <published>2024-06-28T06:38:28.000Z</published>
    <updated>2024-07-04T08:41:10.865Z</updated>
    
    <content type="html"><![CDATA[<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} --><!-- code_chunk_output --><ul><li><a href="#hexo-%E6%93%8D%E4%BD%9C">hexo 操作</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">创建项目</a></li><li><a href="#%E5%90%AF%E5%8A%A8%E8%B0%83%E8%AF%95">启动调试</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0">创建文章</a><ul><li><a href="#markdown%E5%BF%85%E8%A6%81%E6%93%8D%E4%BD%9C">markdown必要操作</a><ul><li><a href="#%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95">设置目录</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">插入图片</a></li></ul></li></ul></li><li><a href="#%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%A2%98pure">设置主题pure</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E6%8E%A8%E9%80%81%E5%88%B0github">部署推送到github</a></li></ul></li></ul><!-- /code_chunk_output --><h1 id="hexo-操作"><a href="#hexo-操作" class="headerlink" title="hexo 操作"></a>hexo 操作</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init snail_book</span><br><span class="line">cd snail_book</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new &#x27;postName&#x27;</span><br><span class="line">hexo n -p 01_pandas/2024-07-04-pandas03</span><br></pre></td></tr></table></figure><h3 id="markdown必要操作"><a href="#markdown必要操作" class="headerlink" title="markdown必要操作"></a>markdown必要操作</h3><h4 id="设置目录"><a href="#设置目录" class="headerlink" title="设置目录"></a>设置目录</h4><p>vscode 安装插件 <code>Markdown Preview Enhanced</code></p><p>你可以通过 <code>cmd/ctrl-shift-p</code> 然后选择 <code>Markdown Preview Enhanced: Create Toc</code> 命令来创建 TOC.</p><p>可查阅如下地址:</p><blockquote><p><a href="https://www.bookstack.cn/read/mpe/zh-cn-toc.md">https://www.bookstack.cn/read/mpe/zh-cn-toc.md</a></p></blockquote><p>需要注意: 需要打开预览后, 再进行 <code>ctrl-s</code> 保持 md 文件, 才会生成目录在 当前 md 文件中.</p><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>推荐一种方式, 在 images 下, 根据知识库的 tags 进行目录创建</p><h2 id="设置主题pure"><a href="#设置主题pure" class="headerlink" title="设置主题pure"></a>设置主题pure</h2><p>pure主题就是我当前用的主题, 还可以</p><h2 id="部署推送到github"><a href="#部署推送到github" class="headerlink" title="部署推送到github"></a>部署推送到github</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#hexo-%E6%93%8D%</summary>
      
    
    
    
    <category term="工具" scheme="https://champion-yang.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="hexo" scheme="https://champion-yang.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>

---
title: redis缓存一致性
date: 2024-07-01 17:55:31
tags: Redis
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [redis 缓存一致性](#redis-缓存一致性)
  - [一、缓存的设计](#一-缓存的设计)
  - [二、数据一致性问题的出现](#二-数据一致性问题的出现)
  - [三、缓存一致性的解决思路](#三-缓存一致性的解决思路)
    - [1. 常用方法: 先更新 db, 后删除 cache](#1-常用方法-先更新-db-后删除-cache)
    - [2. 高并发的时候, 后删缓存还是存在缓存不一致的问题(归根结底还是"删除操作"发生在"更新操作"之前)](#2-高并发的时候-后删缓存还是存在缓存不一致的问题归根结底还是删除操作发生在更新操作之前)
  - [四、缓存击穿问题](#四-缓存击穿问题)

<!-- /code_chunk_output -->


# redis 缓存一致性

在项目中发现大家使用 redis 缓存, 不太注重一致性的设计, 所以整理本文, 希望能给大家一些帮助
{% asset_img image.png xxx %}

## 一、缓存的设计

首先, 读缓存; 
如果缓存里没有值, 那就读取数据库的值; 
同时把这个值写进缓存中.

## 二、数据一致性问题的出现

双更新模式: 操作不合理, 导致数据一致性问题

比如我要更新一个值, 首先刷了缓存, 然后把数据库也更新了. 但过程中, 更新数据库可能会失败, 发生了回滚. 所以, 最后"缓存里的数据"和"数据库的数据"就不一样了, 也就是出现了数据一致性问题.

你或许会说: 我先更新数据库, 再更新缓存不就行了?

这依然会有问题.

考虑到下面的场景: 操作 A 更新 a 的值为 1, 操作 B 更新 a 的值为 2. 由于数据库和 Redis 的操作, 并不是原子的, 它们的执行时长也不是可控制的. 当两个请求的时序发生了错乱, 就会发生缓存不一致的情况.

## 三、缓存一致性的解决思路

### 1. 常用方法: 先更新 db, 后删除 cache

数据的读取过程, 规则是"先读 cache, 再读 db", 详细步骤如下:

* 每次读取数据, 都从 cache 里读; 
* 如果读到了, 则直接返回, 称作 cache hit; 
* 如果读不到 cache 的数据, 则从 db 里面捞一份, 称作 cache miss; 
* 将读取到的数据塞入到缓存中, 下次读取时, 就可以直接命中.

写请求, 规则是"先更新 db, 再删除缓存", 详细步骤如下:

* 将变更写入到数据库中; 
* 删除缓存里对应的数据.

### 2. 高并发的时候, 后删缓存还是存在缓存不一致的问题(归根结底还是"删除操作"发生在"更新操作"之前)

解决方案:

* 延时双删: 而假如我有一种机制, 能够确保删除动作一定被执行, 那就可以解决问题, 起码能缩小数据不一致的时间窗口. 常用的方法就是延时双删, 依然是先更新再删除, 唯一不同的是: 我们把这个删除动作, 在不久之后再执行一次, 比如 5 秒之后. 这种方案需要经过技术选型, 跟着项目走, 可以利用 mq, 延时队列等.

* 闪电缓存: 把缓存的失效时间设置非常短, 比如 3～4 秒. 一旦失效, 就会再次去数据库读取最新数据到缓存. 但这种方式, 在非常高的并发下, 同一时间对某个 key 的请求击穿到 DB, 会锁死数据库, 所以很少用.

## 四、缓存击穿问题

缓存击穿, 指的是缓存中没有数据但数据库中有, 由于同一时刻请求量特别大, 但是没有读到缓存数据, 就会一股脑涌入到数据库中读取, 造成数据库假死.

任何删除缓存的动作都会造成缓存击穿.

所以我们上面一直说的是要删除缓存, 但在极高并发下, 你还不能乱删.
那么该问题如何解决呢?

* 读操作互斥
* 集中更新
* 弱化数据库

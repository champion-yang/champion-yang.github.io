---
title: kafka的消费分区分配策略
toc: true
date: 2024-07-09 16:33:19
tags: Kafka
categories: 技术
---

> 这将是一篇比较无聊的文章

一个consumer group中有多个consumer, 一个topic有多个partition, 所以必然会涉及到partition的分配问题, 即确定那个partition由哪个consumer来消费 Kafka有三种分配策略, 一是RoundRobin, 一是Range. 高版本还有一个StickyAssignor策略 将分区的所有权从一个消费者移到另一个消费者称为重新平衡(rebalance). 当以下事件发生时, Kafka 将会进行一次分区分配:

* 同一个 Consumer Group 内新增消费者.
* 消费者离开当前所属的Consumer Group, 包括shuts down或crashes.

## Range分区分配策略

Range是对每个Topic而言的(即一个Topic一个Topic分), 首先对同一个Topic里面的分区按照序号进行排序, 并对消费者按照字母顺序进行排序. 然后用Partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区. 如果除不尽, 那么前面几个消费者线程将会多消费一个分区. 假设n=分区数/消费者数量, m=分区数%消费者数量, 那么前m个消费者每个分配n+1个分区, 后面的(消费者数
量-m)个消费者每个分配n个分区. 假如有10个分区, 3个消费者线程, 把分区按照序号排列
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
消费者线程为
C1-0, C2-0, C2-1
那么用partition数除以消费者线程的总数来决定每个消费者线程消费几个partition, 如果除不尽, 前面几个消费者将会多消费一个分区. 在我们的例子里面, 我们有10个分区, 3个消费者线程, 10/3 = 3, 而且除不尽, 那么消费者线程C1-0将会多消费一个分区, 所以最后分区分配的结果看起来是这样的:
C1-0:0, 1, 2, 3
C2-0:4, 5, 6
C2-1:7, 8, 9
如果有11个分区将会是:
C1-0:0, 1, 2, 3
C2-0:4, 5, 6, 7
C2-1:8, 9, 10
假如我们有两个主题T1, T2, 分别有10个分区, 最后的分配结果将会是这样:
C1-0: T1(0, 1, 2, 3) T2(0, 1, 2, 3)
C2-0: T1(4, 5, 6) T2(4, 5, 6)
C2-1: T1(7, 8, 9) T2(7, 8, 9)

## RoundRobinAssignor分区分配策略

RoundRobinAssignor策略的原理是将消费组内所有消费者以及消费者所订阅的所有topic的partition按照字典序排序, 然后通过轮询方式逐个将分区以此分配给每个消费者. 使用RoundRobin策略有两个前提条件必须满足:
* 同一个消费者组里面的所有消费者的num.streams(消费者消费线程数)必须相等; 
* 每个消费者订阅的主题必须相同.

加入按照 hashCode 排序完的topic-partitions组依次为
T1-5, T1-3, T1-0, T1-8, T1-2, T1-1, T1-4, T1-7, T1-6, T1-9
我们的消费者线程排序为
C1-0, C1-1, C2-0, C2-1
最后分区分配的结果为:
C1-0 将消费 T1-5, T1-2, T1-6 分区
C1-1 将消费 T1-3, T1-1, T1-9 分区
C2-0 将消费 T1-0, T1-4 分区
C2-1 将消费 T1-8, T1-7 分区

## StickyAssignor分区分配策略

Kafka从0.11.x版本开始引入这种分配策略, 它主要有两个目的:
分区的分配要尽可能的均匀, 分配给消费者者的主题分区数最多相差一个分区的分配尽可能的与上次分配的保持相同.

当两者发生冲突时, 第一个目标优先于第二个目标. 鉴于这两个目的, StickyAssignor策略的具体实现要比RangeAssignor和RoundRobinAssignor这两种分配策略要复杂很多.

假设消费组内有3个消费者
C0、C1、C2
它们都订阅了4个主题:
t0、t1、t2、t3
并且每个主题有2个分区, 也就是说整个消费组订阅了
t0p0、t0p1、t1p0、t1p1、t2p0、t2p1、t3p0、t3p1这8个分区
最终的分配结果如下:
消费者C0:t0p0、t1p1、t3p0
消费者C1:t0p1、t2p0、t3p1
消费者C2:t1p0、t2p1
这样初看上去似乎与采用RoundRobinAssignor策略所分配的结果相同
此时假设消费者C1脱离了消费组, 那么消费组就会执行再平衡操作, 进而消费分区会重新分配. 如果采
用RoundRobinAssignor策略, 那么此时的分配结果如下:
消费者C0:t0p0、t1p0、t2p0、t3p0
消费者C2:t0p1、t1p1、t2p1、t3p1
如分配结果所示, RoundRobinAssignor策略会按照消费者C0和C2进行重新轮询分配. 而如果此时使用
的是StickyAssignor策略, 那么分配结果为:
消费者C0:t0p0、t1p1、t3p0、t2p0
消费者C2:t1p0、t2p1、t0p1、t3p1
可以看到分配结果中保留了上一次分配中对于消费者C0和C2的所有分配结果, 并将原来消费者C1的"负担"分配给了剩余的两个消费者C0和C2, 最终C0和C2的分配还保持了均衡.
如果发生分区重分配, 那么对于同一个分区而言有可能之前的消费者和新指派的消费者不是同一个, 对于之前消费者进行到一半的处理还要在新指派的消费者中再次复现一遍, 这显然很浪费系统资源.
StickyAssignor策略如同其名称中的"sticky"一样, 让分配策略具备一定的"粘性", 尽可能地让前后两次分配相同, 进而减少系统资源的损耗以及其它异常情况的发生. 到目前为止所分析的都是消费者的订阅信息都是相同的情况, 我们来看一下订阅信息不同的情况下的处理.
举例, 同样消费组内有3个消费者:
C0、C1、C2
集群中有3个主题:
t0、t1、t2
这3个主题分别有
1、2、3个分区
也就是说集群中有
t0p0、t1p0、t1p1、t2p0、t2p1、t2p2这6个分区
消费者C0订阅了主题t0
消费者C1订阅了主题t0和t1
消费者C2订阅了主题t0、t1和t2
如果此时采用RoundRobinAssignor策略:
消费者C0:t0p0
消费者C1:t1p0
消费者C2:t1p1、t2p0、t2p1、t2p2
如果此时采用的是StickyAssignor策略:
消费者C0:t0p0
消费者C1:t1p0、t1p1
消费者C2:t2p0、t2p1、t2p2
此时消费者C0脱离了消费组, 那么RoundRobinAssignor策略的分配结果为:
消费者C1:t0p0、t1p1
消费者C2:t1p0、t2p0、t2p1、t2p2
StickyAssignor策略, 那么分配结果为:
消费者C1:t1p0、t1p1、t0p0
消费者C2:t2p0、t2p1、t2p2
可以看到StickyAssignor策略保留了消费者C1和C2中原有的5个分区的分配:
t1p0、t1p1、t2p0、t2p1、t2p2.
从结果上看StickyAssignor策略比另外两者分配策略而言显得更加的优异, 这个策略的代码实现也是异
常复杂.

# 引用

> 公众号: 大数据左右手
